(defun asserta (V1530) (shen.assert* V1530 shen.top))

(defun assertz (V1531) (shen.assert* V1531 shen.bottom))

(defun shen.assert* (V1532 V1533) (cond ((and (cons? V1532) (and (cons? (tl V1532)) (= <-- (hd (tl V1532))))) (let W1534 (shen.predicate (hd V1532)) (let W1535 (shen.terms (hd V1532)) (let W1536 (length W1535) (let W1537 (shen.parameters W1536) (let W1538 (arity W1534) (let W1539 (if (= W1538 -1) (do (eval (shen.create-skeleton W1534 W1537)) (put W1534 shen.dynamic () (value *property-vector*))) shen.skip) (let W1540 (shen.insert-info W1534 W1535 (tl (tl V1532)) V1532 V1533) W1534)))))))) (true (shen.f-error shen.assert*))))

(defun shen.predicate (V1543) (cond ((cons? V1543) (hd V1543)) (true V1543)))

(defun shen.terms (V1548) (cond ((cons? V1548) (tl V1548)) (true ())))

(defun shen.create-skeleton (V1549 V1550) (cons defprolog (cons V1549 (shen.dynamic-default V1549 V1550))))

(defun shen.dynamic-default (V1551 V1552) (append V1552 (cons <-- (cons (cons shen.call-dynamic (cons (shen.cons-form V1552) (cons (cons get (cons V1551 (cons shen.dynamic ()))) ()))) (cons (intern ";") ())))))

(defun shen.insert-info (V1553 V1554 V1555 V1556 V1557) (let W1558 (gensym shen.g) (let W1559 (eval (append (cons defprolog (cons W1558 ())) (append V1554 (cons <-- V1555)))) (let W1560 (cons (fn W1558) (cons W1558 V1556)) (let W1561 (get V1553 shen.dynamic (value *property-vector*)) (let W1562 (if (= V1557 shen.top) (cons W1560 W1561) (append W1561 (cons W1560 ()))) (put V1553 shen.dynamic W1562 (value *property-vector*))))))))

(defun shen.newname () (let W1563 (value shen.*names*) (let W1564 (if (empty? W1563) (gensym shen.g) (do (set shen.*names* (tl W1563)) (hd W1563))) W1564)))

(defun shen.call-dynamic (V1565 V1566 V1567 V1568 V1569 V1570) (let W1571 (if (shen.unlocked? V1568) (let W1572 (shen.lazyderef V1566 V1567) (if (cons? W1572) (let W1573 (shen.lazyderef (hd W1572) V1567) (if (cons? W1573) (let W1574 (hd W1573) (do (shen.incinfs) (shen.callrec W1574 V1565 V1567 V1568 V1569 V1570))) false)) false)) false) (if (= W1571 false) (if (shen.unlocked? V1568) (let W1575 (shen.lazyderef V1566 V1567) (if (cons? W1575) (let W1576 (tl W1575) (do (shen.incinfs) (shen.call-dynamic V1565 W1576 V1567 V1568 V1569 V1570))) false)) false) W1571)))

(defun shen.callrec (V1577 V1578 V1579 V1580 V1581 V1582) (cond ((= () V1578) ((((V1577 V1579) V1580) V1581) V1582)) ((cons? V1578) (shen.callrec (V1577 (hd V1578)) (tl V1578) V1579 V1580 V1581 V1582)) (true (shen.f-error shen.callrec))))

(defun retract (V1583) (cond ((and (cons? V1583) (and (cons? (tl V1583)) (= <-- (hd (tl V1583))))) (let W1584 (shen.predicate (hd V1583)) (let W1585 (get W1584 shen.dynamic (value *property-vector*)) (put W1584 shen.dynamic (shen.retract-clause V1583 W1585) (value *property-vector*))))) (true (shen.f-error retract))))

(defun shen.retract-clause (V1591 V1592) (cond ((= () V1592) ()) ((and (cons? V1592) (and (cons? (hd V1592)) (and (cons? (tl (hd V1592))) (= V1591 (tl (tl (hd V1592))))))) (do (set shen.*names* (cons (hd (tl (hd V1592))) (value shen.*names*))) (tl V1592))) ((cons? V1592) (cons (hd V1592) (shen.retract-clause V1591 (tl V1592)))) (true (shen.f-error shen.retract-clause))))

(defun shen.compile-prolog (V1593 V1594) (compile (lambda Z1595 (shen.<defprolog> Z1595)) (cons V1593 V1594)))

(defun shen.<defprolog> (V1596) (let W1597 (if (cons? V1596) (let W1598 (head V1596) (let W1599 (tail V1596) (let W1600 (shen.<clauses> W1599) (if (shen.parse-failure? W1600) (shen.parse-failure) (let W1601 (shen.<-out W1600) (let W1602 (shen.in-> W1600) (shen.comb W1602 (let W1603 (shen.prolog-arity-check W1598 W1601) (let W1604 (map (lambda Z1605 (shen.linearise-clause Z1605)) W1601) (shen.horn-clause-procedure W1598 W1604)))))))))) (shen.parse-failure)) (if (shen.parse-failure? W1597) (shen.parse-failure) W1597)))

(defun shen.prolog-arity-check (V1608 V1609) (cond ((and (cons? V1609) (and (cons? (hd V1609)) (and (cons? (tl (hd V1609))) (and (= () (tl (tl (hd V1609)))) (= () (tl V1609)))))) (length (hd (hd V1609)))) ((and (cons? V1609) (and (cons? (hd V1609)) (and (cons? (tl (hd V1609))) (= () (tl (tl (hd V1609))))))) (shen.pac-h V1608 (length (hd (hd V1609))) (tl V1609))) (true (shen.f-error shen.prolog-arity-check))))

(defun shen.pac-h (V1614 V1615 V1616) (cond ((= () V1616) V1615) ((and (cons? V1616) (cons? (hd V1616))) (if (= V1615 (length (hd (hd V1616)))) (shen.pac-h V1614 V1615 (tl V1616)) (simple-error (cn "arity error in prolog procedure " (shen.app V1614 "
" shen.a))))) (true (shen.f-error shen.pac-h))))

(defun shen.<clauses> (V1617) (let W1618 (let W1619 (shen.<clause> V1617) (if (shen.parse-failure? W1619) (shen.parse-failure) (let W1620 (shen.<-out W1619) (let W1621 (shen.in-> W1619) (let W1622 (shen.<clauses> W1621) (if (shen.parse-failure? W1622) (shen.parse-failure) (let W1623 (shen.<-out W1622) (let W1624 (shen.in-> W1622) (shen.comb W1624 (cons W1620 W1623)))))))))) (if (shen.parse-failure? W1618) (let W1625 (let W1626 (<!> V1617) (if (shen.parse-failure? W1626) (shen.parse-failure) (let W1627 (shen.<-out W1626) (let W1628 (shen.in-> W1626) (shen.comb W1628 (if (empty? W1627) () (simple-error (cn "Prolog syntax error here:
 " (shen.app W1627 "
 ..." shen.r))))))))) (if (shen.parse-failure? W1625) (shen.parse-failure) W1625)) W1618)))

(defun shen.linearise-clause (V1629) (cond ((and (cons? V1629) (and (cons? (tl V1629)) (= () (tl (tl V1629))))) (shen.lch (shen.linearise (@p (hd V1629) (hd (tl V1629)))))) (true (shen.f-error shen.linearise-clause))))

(defun shen.lch (V1630) (cond ((tuple? V1630) (cons (fst V1630) (cons (shen.lchh (snd V1630)) ()))) (true (shen.f-error shen.lch))))

(defun shen.lchh (V1631) (cond ((and (cons? V1631) (and (= where (hd V1631)) (and (cons? (tl V1631)) (and (cons? (hd (tl V1631))) (and (= = (hd (hd (tl V1631)))) (and (cons? (tl (hd (tl V1631)))) (and (cons? (tl (tl (hd (tl V1631))))) (and (= () (tl (tl (tl (hd (tl V1631)))))) (and (cons? (tl (tl V1631))) (= () (tl (tl (tl V1631))))))))))))) (cons (cons (if (value shen.*occurs*) is! is) (tl (hd (tl V1631)))) (shen.lchh (hd (tl (tl V1631)))))) (true V1631)))

(defun shen.<clause> (V1632) (let W1633 (let W1634 (shen.<head> V1632) (if (shen.parse-failure? W1634) (shen.parse-failure) (let W1635 (shen.<-out W1634) (let W1636 (shen.in-> W1634) (if (shen.hds=? W1636 <--) (let W1637 (tail W1636) (let W1638 (shen.<body> W1637) (if (shen.parse-failure? W1638) (shen.parse-failure) (let W1639 (shen.<-out W1638) (let W1640 (shen.in-> W1638) (let W1641 (shen.<sc> W1640) (if (shen.parse-failure? W1641) (shen.parse-failure) (let W1642 (shen.in-> W1641) (shen.comb W1642 (cons W1635 (cons W1639 ()))))))))))) (shen.parse-failure)))))) (if (shen.parse-failure? W1633) (shen.parse-failure) W1633)))

(defun shen.<head> (V1643) (let W1644 (let W1645 (shen.<hterm> V1643) (if (shen.parse-failure? W1645) (shen.parse-failure) (let W1646 (shen.<-out W1645) (let W1647 (shen.in-> W1645) (let W1648 (shen.<head> W1647) (if (shen.parse-failure? W1648) (shen.parse-failure) (let W1649 (shen.<-out W1648) (let W1650 (shen.in-> W1648) (shen.comb W1650 (cons W1646 W1649)))))))))) (if (shen.parse-failure? W1644) (let W1651 (let W1652 (<e> V1643) (if (shen.parse-failure? W1652) (shen.parse-failure) (let W1653 (shen.in-> W1652) (shen.comb W1653 ())))) (if (shen.parse-failure? W1651) (shen.parse-failure) W1651)) W1644)))

(defun shen.<hterm> (V1654) (let W1655 (if (cons? V1654) (let W1656 (head V1654) (let W1657 (tail V1654) (if (and (atom? W1656) (not (shen.prolog-keyword? W1656))) (shen.comb W1657 W1656) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1655) (let W1658 (if (cons? V1654) (let W1659 (head V1654) (let W1660 (tail V1654) (if (= W1659 (intern ":")) (shen.comb W1660 W1659) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1658) (let W1661 (if (shen.ccons? V1654) (let W1662 (head V1654) (let W1663 (tail V1654) (if (shen.hds=? W1662 cons) (let W1664 (tail W1662) (let W1665 (shen.<hterm1> W1664) (if (shen.parse-failure? W1665) (shen.parse-failure) (let W1666 (shen.<-out W1665) (let W1667 (shen.in-> W1665) (let W1668 (shen.<hterm2> W1667) (if (shen.parse-failure? W1668) (shen.parse-failure) (let W1669 (shen.<-out W1668) (let W1670 (shen.in-> W1668) (let W1671 (<end> W1670) (if (shen.parse-failure? W1671) (shen.parse-failure) (let W1672 (shen.in-> W1671) (shen.comb W1663 (cons cons (cons W1666 (cons W1669 ())))))))))))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1661) (let W1673 (if (shen.ccons? V1654) (let W1674 (head V1654) (let W1675 (tail V1654) (if (shen.hds=? W1674 +) (let W1676 (tail W1674) (let W1677 (shen.<hterm> W1676) (if (shen.parse-failure? W1677) (shen.parse-failure) (let W1678 (shen.<-out W1677) (let W1679 (shen.in-> W1677) (let W1680 (<end> W1679) (if (shen.parse-failure? W1680) (shen.parse-failure) (let W1681 (shen.in-> W1680) (shen.comb W1675 (cons shen.+m (cons W1678 ()))))))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1673) (let W1682 (if (shen.ccons? V1654) (let W1683 (head V1654) (let W1684 (tail V1654) (if (shen.hds=? W1683 -) (let W1685 (tail W1683) (let W1686 (shen.<hterm> W1685) (if (shen.parse-failure? W1686) (shen.parse-failure) (let W1687 (shen.<-out W1686) (let W1688 (shen.in-> W1686) (let W1689 (<end> W1688) (if (shen.parse-failure? W1689) (shen.parse-failure) (let W1690 (shen.in-> W1689) (shen.comb W1684 (cons shen.-m (cons W1687 ()))))))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1682) (let W1691 (if (shen.ccons? V1654) (let W1692 (head V1654) (let W1693 (tail V1654) (if (shen.hds=? W1692 mode) (let W1694 (tail W1692) (let W1695 (shen.<hterm> W1694) (if (shen.parse-failure? W1695) (shen.parse-failure) (let W1696 (shen.<-out W1695) (let W1697 (shen.in-> W1695) (if (shen.hds=? W1697 +) (let W1698 (tail W1697) (let W1699 (<end> W1698) (if (shen.parse-failure? W1699) (shen.parse-failure) (let W1700 (shen.in-> W1699) (shen.comb W1693 (cons shen.+m (cons W1696 ()))))))) (shen.parse-failure))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1691) (let W1701 (if (shen.ccons? V1654) (let W1702 (head V1654) (let W1703 (tail V1654) (if (shen.hds=? W1702 mode) (let W1704 (tail W1702) (let W1705 (shen.<hterm> W1704) (if (shen.parse-failure? W1705) (shen.parse-failure) (let W1706 (shen.<-out W1705) (let W1707 (shen.in-> W1705) (if (shen.hds=? W1707 -) (let W1708 (tail W1707) (let W1709 (<end> W1708) (if (shen.parse-failure? W1709) (shen.parse-failure) (let W1710 (shen.in-> W1709) (shen.comb W1703 (cons shen.-m (cons W1706 ()))))))) (shen.parse-failure))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1701) (shen.parse-failure) W1701)) W1691)) W1682)) W1673)) W1661)) W1658)) W1655)))

(defun shen.prolog-keyword? (V1711) (element? V1711 (cons (intern ";") (cons <-- ()))))

(defun atom? (V1712) (or (symbol? V1712) (or (string? V1712) (or (boolean? V1712) (or (number? V1712) (empty? V1712))))))

(defun shen.<hterm1> (V1713) (let W1714 (let W1715 (shen.<hterm> V1713) (if (shen.parse-failure? W1715) (shen.parse-failure) (let W1716 (shen.<-out W1715) (let W1717 (shen.in-> W1715) (shen.comb W1717 W1716))))) (if (shen.parse-failure? W1714) (shen.parse-failure) W1714)))

(defun shen.<hterm2> (V1718) (let W1719 (let W1720 (shen.<hterm> V1718) (if (shen.parse-failure? W1720) (shen.parse-failure) (let W1721 (shen.<-out W1720) (let W1722 (shen.in-> W1720) (shen.comb W1722 W1721))))) (if (shen.parse-failure? W1719) (shen.parse-failure) W1719)))

(defun shen.<body> (V1723) (let W1724 (let W1725 (shen.<literal> V1723) (if (shen.parse-failure? W1725) (shen.parse-failure) (let W1726 (shen.<-out W1725) (let W1727 (shen.in-> W1725) (let W1728 (shen.<body> W1727) (if (shen.parse-failure? W1728) (shen.parse-failure) (let W1729 (shen.<-out W1728) (let W1730 (shen.in-> W1728) (shen.comb W1730 (cons W1726 W1729)))))))))) (if (shen.parse-failure? W1724) (let W1731 (let W1732 (<e> V1723) (if (shen.parse-failure? W1732) (shen.parse-failure) (let W1733 (shen.in-> W1732) (shen.comb W1733 ())))) (if (shen.parse-failure? W1731) (shen.parse-failure) W1731)) W1724)))

(defun shen.<literal> (V1734) (let W1735 (if (shen.hds=? V1734 !) (let W1736 (tail V1734) (shen.comb W1736 !)) (shen.parse-failure)) (if (shen.parse-failure? W1735) (let W1737 (if (shen.ccons? V1734) (let W1738 (head V1734) (let W1739 (tail V1734) (let W1740 (shen.<bterms> W1738) (if (shen.parse-failure? W1740) (shen.parse-failure) (let W1741 (shen.<-out W1740) (let W1742 (shen.in-> W1740) (let W1743 (<end> W1742) (if (shen.parse-failure? W1743) (shen.parse-failure) (let W1744 (shen.in-> W1743) (shen.comb W1739 W1741)))))))))) (shen.parse-failure)) (if (shen.parse-failure? W1737) (shen.parse-failure) W1737)) W1735)))

(defun shen.<bterms> (V1745) (let W1746 (let W1747 (shen.<bterm> V1745) (if (shen.parse-failure? W1747) (shen.parse-failure) (let W1748 (shen.<-out W1747) (let W1749 (shen.in-> W1747) (let W1750 (shen.<bterms> W1749) (if (shen.parse-failure? W1750) (shen.parse-failure) (let W1751 (shen.<-out W1750) (let W1752 (shen.in-> W1750) (shen.comb W1752 (cons W1748 W1751)))))))))) (if (shen.parse-failure? W1746) (let W1753 (let W1754 (<e> V1745) (if (shen.parse-failure? W1754) (shen.parse-failure) (let W1755 (shen.in-> W1754) (shen.comb W1755 ())))) (if (shen.parse-failure? W1753) (shen.parse-failure) W1753)) W1746)))

(defun shen.<bterm> (V1756) (let W1757 (let W1758 (shen.<wildcard> V1756) (if (shen.parse-failure? W1758) (shen.parse-failure) (let W1759 (shen.<-out W1758) (let W1760 (shen.in-> W1758) (shen.comb W1760 W1759))))) (if (shen.parse-failure? W1757) (let W1761 (if (cons? V1756) (let W1762 (head V1756) (let W1763 (tail V1756) (if (atom? W1762) (shen.comb W1763 W1762) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1761) (let W1764 (if (shen.ccons? V1756) (let W1765 (head V1756) (let W1766 (tail V1756) (let W1767 (shen.<bterms> W1765) (if (shen.parse-failure? W1767) (shen.parse-failure) (let W1768 (shen.<-out W1767) (let W1769 (shen.in-> W1767) (let W1770 (<end> W1769) (if (shen.parse-failure? W1770) (shen.parse-failure) (let W1771 (shen.in-> W1770) (shen.comb W1766 W1768)))))))))) (shen.parse-failure)) (if (shen.parse-failure? W1764) (shen.parse-failure) W1764)) W1761)) W1757)))

(defun shen.<wildcard> (V1772) (let W1773 (if (cons? V1772) (let W1774 (head V1772) (let W1775 (tail V1772) (if (= W1774 _) (shen.comb W1775 (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1773) (shen.parse-failure) W1773)))

(defun shen.<sc> (V1776) (let W1777 (if (cons? V1776) (let W1778 (head V1776) (let W1779 (tail V1776) (if (shen.semicolon? W1778) (shen.comb W1779 W1778) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W1777) (shen.parse-failure) W1777)))

(defun shen.semicolon? (V1780) (= V1780 (intern ";")))

(defun shen.horn-clause-procedure (V1781 V1782) (let W1783 (gensym B) (let W1784 (gensym L) (let W1785 (gensym K) (let W1786 (gensym C) (let W1787 (shen.prolog-parameters V1782) (let W1788 (shen.hascut? V1782) (let W1789 (shen.prolog-fbody V1782 W1787 W1783 W1784 W1785 W1786 W1788) (let W1790 (if W1788 (cons let (cons W1785 (cons (cons + (cons W1785 (cons 1 ()))) (cons W1789 ())))) W1789) (let W1791 (cons define (cons V1781 (append W1787 (append (cons W1783 (cons W1784 (cons W1785 (cons W1786 (cons -> ()))))) (cons W1790 ()))))) W1791))))))))))

(defun shen.hascut? (V1794) (cond ((= ! V1794) true) ((cons? V1794) (or (shen.hascut? (hd V1794)) (shen.hascut? (tl V1794)))) (true false)))

(defun shen.prolog-parameters (V1799) (cond ((and (cons? V1799) (cons? (hd V1799))) (shen.parameters (length (hd (hd V1799))))) (true (shen.f-error shen.prolog-parameters))))

(defun shen.prolog-fbody (V1820 V1821 V1822 V1823 V1824 V1825 V1826) (cond ((and (= () V1820) (= true V1826)) (cons shen.unlock (cons V1823 (cons V1824 ())))) ((and (cons? V1820) (and (cons? (hd V1820)) (and (cons? (tl (hd V1820))) (and (= () (tl (tl (hd V1820)))) (and (= () (tl V1820)) (= false V1826)))))) (let W1827 (shen.continue (hd (hd V1820)) (hd (tl (hd V1820))) V1822 V1823 V1824 V1825) (cons if (cons (cons shen.unlocked? (cons V1823 ())) (cons (shen.compile-head shen.+m (hd (hd V1820)) V1821 V1822 W1827) (cons false ())))))) ((and (cons? V1820) (and (cons? (hd V1820)) (and (cons? (tl (hd V1820))) (= () (tl (tl (hd V1820))))))) (let W1828 (gensym C) (let W1829 (shen.continue (hd (hd V1820)) (hd (tl (hd V1820))) V1822 V1823 V1824 V1825) (cons let (cons W1828 (cons (cons if (cons (cons shen.unlocked? (cons V1823 ())) (cons (shen.compile-head shen.+m (hd (hd V1820)) V1821 V1822 W1829) (cons false ())))) (cons (cons if (cons (cons = (cons W1828 (cons false ()))) (cons (shen.prolog-fbody (tl V1820) V1821 V1822 V1823 V1824 V1825 V1826) (cons W1828 ())))) ()))))))) (true (simple-error "implementation error in shen.prolog-fbody"))))

(defun shen.unlock (V1830 V1831) (if (and (shen.locked? V1830) (shen.fits? V1831 V1830)) (shen.openlock V1830) false))

(defun shen.locked? (V1832) (not (shen.unlocked? V1832)))

(defun shen.unlocked? (V1833) (<-address V1833 1))

(defun shen.openlock (V1834) (do (address-> V1834 1 true) false))

(defun shen.fits? (V1835 V1836) (= V1835 (<-address V1836 2)))

(defun shen.cut (V1839 V1840 V1841 V1842) (let W1843 (thaw V1842) (if (and (= W1843 false) (shen.unlocked? V1840)) (shen.lock V1841 V1840) W1843)))

(defun shen.lock (V1844 V1845) (let W1846 (address-> V1845 1 false) (let W1847 (address-> V1845 2 V1844) false)))

(defun shen.continue (V1848 V1849 V1850 V1851 V1852 V1853) (let W1854 (shen.extract-vars V1848) (let W1855 (shen.extract-free-vars V1849) (let W1856 (difference W1855 W1854) (let W1857 (cons do (cons (cons shen.incinfs ()) (cons (shen.compile-body V1849 V1850 V1851 V1852 V1853) ()))) (shen.stpart W1856 W1857 V1850))))))

(defun shen.extract-free-vars (V1860) (cond ((and (cons? V1860) (and (= lambda (hd V1860)) (and (cons? (tl V1860)) (and (cons? (tl (tl V1860))) (= () (tl (tl (tl V1860)))))))) (remove (hd (tl V1860)) (shen.extract-free-vars (hd (tl (tl V1860)))))) ((cons? V1860) (union (shen.extract-free-vars (hd V1860)) (shen.extract-free-vars (tl V1860)))) ((variable? V1860) (cons V1860 ())) (true ())))

(defun shen.compile-body (V1877 V1878 V1879 V1880 V1881) (cond ((= () V1877) (cons thaw (cons V1881 ()))) ((and (cons? V1877) (= ! (hd V1877))) (shen.compile-body (cons (cons shen.cut ()) (tl V1877)) V1878 V1879 V1880 V1881)) ((and (cons? V1877) (= () (tl V1877))) (append (shen.deref-calls (hd V1877) V1878) (cons V1878 (cons V1879 (cons V1880 (cons V1881 ())))))) ((cons? V1877) (let W1882 (shen.deref-calls (hd V1877) V1878) (append W1882 (cons V1878 (cons V1879 (cons V1880 (cons (shen.freeze-literals (tl V1877) V1878 V1879 V1880 V1881) ()))))))) (true (simple-error "implementation error in shen.compile-fbody"))))

(defun shen.freeze-literals (V1899 V1900 V1901 V1902 V1903) (cond ((= () V1899) V1903) ((and (cons? V1899) (= ! (hd V1899))) (shen.freeze-literals (cons (cons shen.cut ()) (tl V1899)) V1900 V1901 V1902 V1903)) ((cons? V1899) (let W1904 (shen.deref-calls (hd V1899) V1900) (cons freeze (cons (append W1904 (cons V1900 (cons V1901 (cons V1902 (cons (shen.freeze-literals (tl V1899) V1900 V1901 V1902 V1903) ()))))) ())))) (true (simple-error "implementation error in shen.freeze-literals"))))

(defun shen.deref-calls (V1909 V1910) (cond ((and (cons? V1909) (= fork (hd V1909))) (cons fork (cons (shen.deref-forked-literals (tl V1909) V1910) ()))) ((cons? V1909) (cons (hd V1909) (map (lambda Z1911 (shen.function-calls Z1911 V1910)) (tl V1909)))) (true (simple-error "implementation error in shen.deref-calls"))))

(defun shen.deref-forked-literals (V1918 V1919) (cond ((= () V1918) ()) ((cons? V1918) (cons cons (cons (shen.deref-calls (hd V1918) V1919) (cons (shen.deref-forked-literals (tl V1918) V1919) ())))) (true (simple-error "fork requires a list of literals
"))))

(defun shen.function-calls (V1922 V1923) (cond ((and (cons? V1922) (and (= cons (hd V1922)) (and (cons? (tl V1922)) (and (cons? (tl (tl V1922))) (= () (tl (tl (tl V1922)))))))) (cons cons (cons (shen.function-calls (hd (tl V1922)) V1923) (cons (shen.function-calls (hd (tl (tl V1922))) V1923) ())))) ((cons? V1922) (shen.deref-terms V1922 V1923 ())) (true V1922)))

(defun shen.deref-terms (V1932 V1933 V1934) (cond ((and (cons? V1932) (and (= 0 (hd V1932)) (and (cons? (tl V1932)) (= () (tl (tl V1932)))))) (if (variable? (hd (tl V1932))) (hd (tl V1932)) (simple-error (cn "attempt to optimise a non-variable " (shen.app (hd (tl V1932)) "
" shen.s))))) ((and (cons? V1932) (and (= 1 (hd V1932)) (and (cons? (tl V1932)) (= () (tl (tl V1932)))))) (if (variable? (hd (tl V1932))) (cons shen.lazyderef (cons (hd (tl V1932)) (cons V1933 ()))) (simple-error (cn "attempt to optimise a non-variable " (shen.app (hd (tl V1932)) "
" shen.s))))) ((and (not (element? V1932 V1934)) (variable? V1932)) (cons shen.deref (cons V1932 (cons V1933 ())))) ((and (cons? V1932) (and (= lambda (hd V1932)) (and (cons? (tl V1932)) (and (cons? (tl (tl V1932))) (= () (tl (tl (tl V1932)))))))) (cons lambda (cons (hd (tl V1932)) (cons (shen.deref-terms (hd (tl (tl V1932))) V1933 (cons (hd (tl V1932)) V1934)) ())))) ((cons? V1932) (map (lambda Z1935 (shen.deref-terms Z1935 V1933 V1934)) V1932)) (true V1932)))

(defun shen.compile-head (V1953 V1954 V1955 V1956 V1957) (cond ((and (= () V1954) (= () V1955)) V1957) ((and (cons? V1954) (and (cons? (hd V1954)) (and (= shen.+m (hd (hd V1954))) (and (cons? (tl (hd V1954))) (= () (tl (tl (hd V1954)))))))) (shen.compile-head V1953 (cons shen.+m (cons (hd (tl (hd V1954))) (cons V1953 (tl V1954)))) V1955 V1956 V1957)) ((and (cons? V1954) (and (cons? (hd V1954)) (and (= shen.-m (hd (hd V1954))) (and (cons? (tl (hd V1954))) (= () (tl (tl (hd V1954)))))))) (shen.compile-head V1953 (cons shen.-m (cons (hd (tl (hd V1954))) (cons V1953 (tl V1954)))) V1955 V1956 V1957)) ((and (cons? V1954) (= shen.-m (hd V1954))) (shen.compile-head shen.-m (tl V1954) V1955 V1956 V1957)) ((and (cons? V1954) (= shen.+m (hd V1954))) (shen.compile-head shen.+m (tl V1954) V1955 V1956 V1957)) ((and (cons? V1954) (and (cons? V1955) (shen.wildcard? (hd V1954)))) (shen.compile-head V1953 (tl V1954) (tl V1955) V1956 V1957)) ((and (cons? V1954) (variable? (hd V1954))) (shen.variable-case V1953 V1954 V1955 V1956 V1957)) ((and (= shen.-m V1953) (and (cons? V1954) (atom? (hd V1954)))) (shen.atom-case-minus V1954 V1955 V1956 V1957)) ((and (= shen.-m V1953) (and (cons? V1954) (and (cons? (hd V1954)) (and (= cons (hd (hd V1954))) (and (cons? (tl (hd V1954))) (and (cons? (tl (tl (hd V1954)))) (= () (tl (tl (tl (hd V1954))))))))))) (shen.cons-case-minus V1954 V1955 V1956 V1957)) ((and (= shen.+m V1953) (and (cons? V1954) (atom? (hd V1954)))) (shen.atom-case-plus V1954 V1955 V1956 V1957)) ((and (= shen.+m V1953) (and (cons? V1954) (and (cons? (hd V1954)) (and (= cons (hd (hd V1954))) (and (cons? (tl (hd V1954))) (and (cons? (tl (tl (hd V1954)))) (= () (tl (tl (tl (hd V1954))))))))))) (shen.cons-case-plus V1954 V1955 V1956 V1957)) (true (simple-error "implementation error in shen.compile-head"))))

(defun shen.variable-case (V1968 V1969 V1970 V1971 V1972) (cond ((and (cons? V1969) (cons? V1970)) (if (variable? (hd V1970)) (shen.compile-head V1968 (tl V1969) (tl V1970) V1971 (subst (hd V1970) (hd V1969) V1972)) (cons let (cons (hd V1969) (cons (hd V1970) (cons (shen.compile-head V1968 (tl V1969) (tl V1970) V1971 V1972) ())))))) (true (simple-error "implementation error in shen.variable-case"))))

(defun shen.atom-case-minus (V1981 V1982 V1983 V1984) (cond ((and (cons? V1981) (cons? V1982)) (let W1985 (gensym Tm) (cons let (cons W1985 (cons (cons shen.lazyderef (cons (hd V1982) (cons V1983 ()))) (cons (cons if (cons (cons = (cons W1985 (cons (hd V1981) ()))) (cons (shen.compile-head shen.-m (tl V1981) (tl V1982) V1983 V1984) (cons false ())))) ())))))) (true (simple-error "implementation error in shen.atom-case-minus"))))

(defun shen.cons-case-minus (V1994 V1995 V1996 V1997) (cond ((and (cons? V1994) (and (cons? (hd V1994)) (and (= cons (hd (hd V1994))) (and (cons? (tl (hd V1994))) (and (cons? (tl (tl (hd V1994)))) (and (= () (tl (tl (tl (hd V1994))))) (cons? V1995))))))) (let W1998 (gensym Tm) (cons let (cons W1998 (cons (cons shen.lazyderef (cons (hd V1995) (cons V1996 ()))) (cons (cons if (cons (cons cons? (cons W1998 ())) (cons (shen.compile-head shen.-m (cons (hd (tl (hd V1994))) (cons (hd (tl (tl (hd V1994)))) (tl V1994))) (cons (cons hd (cons W1998 ())) (cons (cons tl (cons W1998 ())) (tl V1995))) V1996 V1997) (cons false ())))) ())))))) (true (simple-error "implementation error in shen.cons-case-minus"))))

(defun shen.atom-case-plus (V2007 V2008 V2009 V2010) (cond ((and (cons? V2007) (cons? V2008)) (let W2011 (gensym Tm) (let W2012 (gensym GoTo) (cons let (cons W2011 (cons (cons shen.lazyderef (cons (hd V2008) (cons V2009 ()))) (cons W2012 (cons (cons freeze (cons (shen.compile-head shen.+m (tl V2007) (tl V2008) V2009 V2010) ())) (cons (cons if (cons (cons = (cons W2011 (cons (hd V2007) ()))) (cons (cons thaw (cons W2012 ())) (cons (cons if (cons (cons shen.pvar? (cons W2011 ())) (cons (cons shen.bind! (cons W2011 (cons (shen.demode (hd V2007)) (cons V2009 (cons W2012 ()))))) (cons false ())))) ())))) ()))))))))) (true (simple-error "implementation error in shen.atom-case-plus"))))

(defun shen.cons-case-plus (V2021 V2022 V2023 V2024) (cond ((and (cons? V2021) (and (cons? (hd V2021)) (and (= cons (hd (hd V2021))) (and (cons? (tl (hd V2021))) (and (cons? (tl (tl (hd V2021)))) (and (= () (tl (tl (tl (hd V2021))))) (cons? V2022))))))) (let W2025 (gensym Tm) (let W2026 (gensym GoTo) (let W2027 (shen.extract-vars (cons (hd (tl (hd V2021))) (hd (tl (tl (hd V2021)))))) (let W2028 (shen.tame (hd V2021)) (let W2029 (shen.extract-vars W2028) (cons let (cons W2025 (cons (cons shen.lazyderef (cons (hd V2022) (cons V2023 ()))) (cons W2026 (cons (shen.goto W2027 (shen.compile-head shen.+m (tl V2021) (tl V2022) V2023 V2024)) (cons (cons if (cons (cons cons? (cons W2025 ())) (cons (shen.compile-head shen.+m (tl (hd V2021)) (cons (cons hd (cons W2025 ())) (cons (cons tl (cons W2025 ())) ())) V2023 (shen.invoke W2026 W2027)) (cons (cons if (cons (cons shen.pvar? (cons W2025 ())) (cons (shen.stpart W2029 (cons shen.bind! (cons W2025 (cons (shen.demode W2028) (cons V2023 (cons (cons freeze (cons (shen.invoke W2026 W2027) ())) ()))))) V2023) (cons false ())))) ())))) ())))))))))))) (true (simple-error "implementation error in shen.cons-case-plus"))))

(defun shen.demode (V2030) (cond ((and (cons? V2030) (and (= shen.+m (hd V2030)) (and (cons? (tl V2030)) (= () (tl (tl V2030)))))) (shen.demode (hd (tl V2030)))) ((and (cons? V2030) (and (= shen.-m (hd V2030)) (and (cons? (tl V2030)) (= () (tl (tl V2030)))))) (shen.demode (hd (tl V2030)))) ((cons? V2030) (map (lambda Z2031 (shen.demode Z2031)) V2030)) (true V2030)))

(defun shen.tame (V2032) (cond ((shen.wildcard? V2032) (gensym Y)) ((cons? V2032) (map (lambda Z2033 (shen.tame Z2033)) V2032)) (true V2032)))

(defun shen.goto (V2034 V2035) (cond ((= () V2034) (cons freeze (cons V2035 ()))) (true (shen.goto-h V2034 V2035))))

(defun shen.goto-h (V2036 V2037) (cond ((= () V2036) V2037) ((cons? V2036) (cons lambda (cons (hd V2036) (cons (shen.goto-h (tl V2036) V2037) ())))) (true (shen.f-error shen.goto-h))))

(defun shen.invoke (V2038 V2039) (cond ((= () V2039) (cons thaw (cons V2038 ()))) (true (cons V2038 V2039))))

(defun shen.wildcard? (V2040) (= V2040 _))

(defun shen.pvar? (V2041) (and (absvector? V2041) (= (trap-error (<-address V2041 0) (lambda Z2042 shen.not-pvar)) shen.pvar)))

(defun shen.lazyderef (V2043 V2044) (if (shen.pvar? V2043) (let W2045 (<-address V2044 (<-address V2043 1)) (if (= W2045 shen.-null-) V2043 (shen.lazyderef W2045 V2044))) V2043))

(defun shen.deref (V2046 V2047) (cond ((cons? V2046) (cons (shen.deref (hd V2046) V2047) (shen.deref (tl V2046) V2047))) (true (if (shen.pvar? V2046) (let W2048 (<-address V2047 (<-address V2046 1)) (if (= W2048 shen.-null-) V2046 (shen.deref W2048 V2047))) V2046))))

(defun shen.bind! (V2049 V2050 V2051 V2052) (let W2053 (shen.bindv V2049 V2050 V2051) (let W2054 (thaw V2052) (if (= W2054 false) (shen.unwind V2049 V2051 W2054) W2054))))

(defun shen.bindv (V2055 V2056 V2057) (address-> V2057 (<-address V2055 1) V2056))

(defun shen.unwind (V2058 V2059 V2060) (do (address-> V2059 (<-address V2058 1) shen.-null-) V2060))

(defun shen.stpart (V2069 V2070 V2071) (cond ((= () V2069) V2070) ((cons? V2069) (cons let (cons (hd V2069) (cons (cons shen.newpv (cons V2071 ())) (cons (cons shen.gc (cons V2071 (cons (shen.stpart (tl V2069) V2070 V2071) ()))) ()))))) (true (simple-error "implementation error in shen.stpart"))))

(defun shen.gc (V2072 V2073) (if (= V2073 false) (let W2074 (shen.ticket-number V2072) (do (shen.decrement-ticket W2074 V2072) V2073)) V2073))

(defun shen.decrement-ticket (V2075 V2076) (address-> V2076 1 (- V2075 1)))

(defun shen.newpv (V2077) (let W2078 (shen.ticket-number V2077) (let W2079 (shen.make-prolog-variable W2078) (let W2080 (shen.nextticket V2077 W2078) W2079))))

(defun shen.ticket-number (V2081) (<-address V2081 1))

(defun shen.nextticket (V2082 V2083) (let W2084 (address-> V2082 V2083 shen.-null-) (address-> W2084 1 (+ V2083 1))))

(defun shen.make-prolog-variable (V2085) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V2085))

(defun shen.pvar (V2086) (cn "Var" (shen.app (<-address V2086 1) "" shen.a)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.prolog-vector-size (V2087) (if (and (integer? V2087) (> V2087 0)) (set shen.*size-prolog-vector* V2087) (simple-error (cn "prolog vector size: size should be a positive integer; not " (shen.app V2087 "" shen.a)))))

(defun shen.lzy=! (V2099 V2100 V2101 V2102) (cond ((= V2099 V2100) (thaw V2102)) ((and (shen.pvar? V2099) (not (shen.occurs? V2099 (shen.deref V2100 V2101)))) (shen.bind! V2099 V2100 V2101 V2102)) ((and (shen.pvar? V2100) (not (shen.occurs? V2100 (shen.deref V2099 V2101)))) (shen.bind! V2100 V2099 V2101 V2102)) ((and (cons? V2099) (cons? V2100)) (shen.lzy=! (shen.lazyderef (hd V2099) V2101) (shen.lazyderef (hd V2100) V2101) V2101 (freeze (shen.lzy=! (shen.lazyderef (tl V2099) V2101) (shen.lazyderef (tl V2100) V2101) V2101 V2102)))) (true false)))

(defun shen.lzy= (V2114 V2115 V2116 V2117) (cond ((= V2114 V2115) (thaw V2117)) ((shen.pvar? V2114) (shen.bind! V2114 V2115 V2116 V2117)) ((shen.pvar? V2115) (shen.bind! V2115 V2114 V2116 V2117)) ((and (cons? V2114) (cons? V2115)) (shen.lzy= (shen.lazyderef (hd V2114) V2116) (shen.lazyderef (hd V2115) V2116) V2116 (freeze (shen.lzy= (shen.lazyderef (tl V2114) V2116) (shen.lazyderef (tl V2115) V2116) V2116 V2117)))) (true false)))

(defun shen.occurs? (V2123 V2124) (cond ((= V2123 V2124) true) ((cons? V2124) (or (shen.occurs? V2123 (hd V2124)) (shen.occurs? V2123 (tl V2124)))) (true false)))

(defun call (V2125 V2126 V2127 V2128 V2129) ((((V2125 V2126) V2127) V2128) V2129))

(defun return (V2136 V2137 V2138 V2139 V2140) (shen.deref V2136 V2137))

(defun when (V2147 V2148 V2149 V2150 V2151) (if V2147 (thaw V2151) false))

(defun is (V2152 V2153 V2154 V2155 V2156 V2157) (shen.lzy= (shen.lazyderef V2152 V2154) (shen.lazyderef V2153 V2154) V2154 V2157))

(defun is! (V2158 V2159 V2160 V2161 V2162 V2163) (shen.lzy=! (shen.lazyderef V2158 V2160) (shen.lazyderef V2159 V2160) V2160 V2163))

(defun bind (V2168 V2169 V2170 V2171 V2172 V2173) (shen.bind! V2168 V2169 V2170 V2173))

(defun var? (V2174 V2175 V2176 V2177 V2178) (if (shen.pvar? (shen.lazyderef V2174 V2175)) (thaw V2178) false))

(defun shen.print-prolog-vector (V2181) "|prolog vector|")

(defun fork (V2200 V2201 V2202 V2203 V2204) (cond ((= () V2200) false) ((cons? V2200) (let W2205 (((((hd V2200) V2201) V2202) V2203) V2204) (if (= W2205 false) (fork (tl V2200) V2201 V2202 V2203 V2204) W2205))) (true (simple-error "fork expects a list of literals
"))))

(defun findall (V2206 V2207 V2208 V2209 V2210 V2211 V2212) (if (shen.unlocked? V2210) (let W2213 (shen.newpv V2209) (shen.gc V2209 (do (shen.incinfs) (is W2213 () V2209 V2210 V2211 (freeze (shen.findall-h V2206 V2207 V2208 W2213 V2209 V2210 V2211 V2212)))))) false))

(defun shen.findall-h (V2214 V2215 V2216 V2217 V2218 V2219 V2220 V2221) (let W2222 (if (shen.unlocked? V2219) (do (shen.incinfs) (call V2215 V2218 V2219 V2220 (freeze (shen.overbind V2214 V2217 V2218 V2219 V2220 V2221)))) false) (if (= W2222 false) (if (shen.unlocked? V2219) (do (shen.incinfs) (is! V2216 V2217 V2218 V2219 V2220 V2221)) false) W2222)))

(defun shen.overbind (V2229 V2230 V2231 V2232 V2233 V2234) (do (shen.bindv V2230 (cons (shen.deref V2229 V2231) (shen.lazyderef V2230 V2231)) V2231) false))

(defun occurs-check (V2237) (cond ((= + V2237) (set shen.*occurs* true)) ((= - V2237) (set shen.*occurs* false)) (true (simple-error "occurs-check expects a + or a -.
"))))

