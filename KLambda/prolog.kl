(defun asserta (V8093) (shen.assert* V8093 shen.top))

(defun assertz (V8094) (shen.assert* V8094 shen.bottom))

(defun shen.assert* (V8095 V8096) (cond ((and (cons? V8095) (and (cons? (tl V8095)) (= <-- (hd (tl V8095))))) (let W8097 (shen.predicate (hd V8095)) (let W8098 (shen.terms (hd V8095)) (let W8099 (length W8098) (let W8100 (shen.parameters W8099) (let W8101 (arity W8097) (let W8102 (if (= W8101 -1) (do (eval (shen.create-skeleton W8097 W8100)) (put W8097 shen.dynamic () (value *property-vector*))) shen.skip) (let W8103 (shen.insert-info W8097 W8098 (tl (tl V8095)) V8095 V8096) W8097)))))))) (true (simple-error "partial function shen.assert*"))))

(defun shen.predicate (V8106) (cond ((cons? V8106) (hd V8106)) (true V8106)))

(defun shen.terms (V8111) (cond ((cons? V8111) (tl V8111)) (true ())))

(defun shen.create-skeleton (V8112 V8113) (cons defprolog (cons V8112 (shen.dynamic-default V8112 V8113))))

(defun shen.dynamic-default (V8114 V8115) (append V8115 (cons <-- (cons (cons shen.call-dynamic (cons (shen.cons-form V8115) (cons (cons get (cons V8114 (cons shen.dynamic ()))) ()))) (cons (intern ";") ())))))

(defun shen.insert-info (V8116 V8117 V8118 V8119 V8120) (let W8121 (gensym shen.g) (let W8122 (eval (append (cons defprolog (cons W8121 ())) (append V8117 (cons <-- V8118)))) (let W8123 (cons (fn W8121) V8119) (let W8124 (get V8116 shen.dynamic (value *property-vector*)) (let W8125 (if (= V8120 shen.top) (cons W8123 W8124) (append W8124 (cons W8123 ()))) (put V8116 shen.dynamic W8125 (value *property-vector*))))))))

(defun shen.call-dynamic (V8126 V8127 V8128 V8129 V8130 V8131) (let W8132 (if (shen.unlocked? V8129) (let W8133 (shen.lazyderef V8127 V8128) (if (cons? W8133) (let W8134 (shen.lazyderef (hd W8133) V8128) (if (cons? W8134) (let W8135 (hd W8134) (do (shen.incinfs) (shen.callrec W8135 V8126 V8128 V8129 V8130 V8131))) false)) false)) false) (if (= W8132 false) (if (shen.unlocked? V8129) (let W8136 (shen.lazyderef V8127 V8128) (if (cons? W8136) (let W8137 (tl W8136) (do (shen.incinfs) (shen.call-dynamic V8126 W8137 V8128 V8129 V8130 V8131))) false)) false) W8132)))

(defun shen.callrec (V8138 V8139 V8140 V8141 V8142 V8143) (cond ((= () V8139) ((((V8138 V8140) V8141) V8142) V8143)) ((cons? V8139) (shen.callrec (V8138 (hd V8139)) (tl V8139) V8140 V8141 V8142 V8143)) (true (simple-error "partial function shen.callrec"))))

(defun retract (V8144) (cond ((and (cons? V8144) (and (cons? (tl V8144)) (= <-- (hd (tl V8144))))) (let W8145 (shen.predicate (hd V8144)) (let W8146 (get W8145 shen.dynamic (value *property-vector*)) (put W8145 shen.dynamic (shen.retract-clause V8144 W8146) (value *property-vector*))))) (true (simple-error "partial function retract"))))

(defun shen.retract-clause (V8152 V8153) (cond ((= () V8153) ()) ((and (cons? V8153) (and (cons? (hd V8153)) (= V8152 (tl (hd V8153))))) (tl V8153)) ((cons? V8153) (cons (hd V8153) (shen.retract-clause V8152 (tl V8153)))) (true (simple-error "partial function shen.retract-clause"))))

(defun shen.compile-prolog (V8154 V8155) (compile (lambda Z8156 (shen.<defprolog> Z8156)) (cons V8154 V8155)))

(defun shen.<defprolog> (V8157) (let W8158 (if (cons? V8157) (let W8159 (head V8157) (let W8160 (tail V8157) (let W8161 (shen.<clauses> W8160) (if (shen.parse-failure? W8161) (shen.parse-failure) (let W8162 (shen.<-out W8161) (let W8163 (shen.in-> W8161) (shen.comb W8163 (let W8164 (shen.prolog-arity-check W8159 W8162) (let W8165 (map (lambda Z8166 (shen.linearise-clause Z8166)) W8162) (shen.horn-clause-procedure W8159 W8165)))))))))) (shen.parse-failure)) (if (shen.parse-failure? W8158) (shen.parse-failure) W8158)))

(defun shen.prolog-arity-check (V8169 V8170) (cond ((and (cons? V8170) (and (cons? (hd V8170)) (and (cons? (tl (hd V8170))) (and (= () (tl (tl (hd V8170)))) (= () (tl V8170)))))) (length (hd (hd V8170)))) ((and (cons? V8170) (and (cons? (hd V8170)) (and (cons? (tl (hd V8170))) (= () (tl (tl (hd V8170))))))) (shen.pac-h V8169 (length (hd (hd V8170))) (tl V8170))) (true (simple-error "partial function shen.prolog-arity-check"))))

(defun shen.pac-h (V8175 V8176 V8177) (cond ((= () V8177) V8176) ((and (cons? V8177) (cons? (hd V8177))) (if (= V8176 (length (hd (hd V8177)))) (shen.pac-h V8175 V8176 (tl V8177)) (simple-error (cn "arity error in prolog procedure " (shen.app V8175 "
" shen.a))))) (true (simple-error "partial function shen.pac-h"))))

(defun shen.<clauses> (V8178) (let W8179 (let W8180 (shen.<clause> V8178) (if (shen.parse-failure? W8180) (shen.parse-failure) (let W8181 (shen.<-out W8180) (let W8182 (shen.in-> W8180) (let W8183 (shen.<clauses> W8182) (if (shen.parse-failure? W8183) (shen.parse-failure) (let W8184 (shen.<-out W8183) (let W8185 (shen.in-> W8183) (shen.comb W8185 (cons W8181 W8184)))))))))) (if (shen.parse-failure? W8179) (let W8186 (let W8187 (<!> V8178) (if (shen.parse-failure? W8187) (shen.parse-failure) (let W8188 (shen.<-out W8187) (let W8189 (shen.in-> W8187) (shen.comb W8189 (if (empty? W8188) () (simple-error (cn "Prolog syntax error here:
 " (shen.app W8188 "
 ..." shen.r))))))))) (if (shen.parse-failure? W8186) (shen.parse-failure) W8186)) W8179)))

(defun shen.linearise-clause (V8190) (cond ((and (cons? V8190) (and (cons? (tl V8190)) (= () (tl (tl V8190))))) (shen.lch (shen.linearise (@p (hd V8190) (hd (tl V8190)))))) (true (simple-error "partial function shen.linearise-clause"))))

(defun shen.lch (V8191) (cond ((tuple? V8191) (cons (fst V8191) (cons (shen.lchh (snd V8191)) ()))) (true (simple-error "partial function shen.lch"))))

(defun shen.lchh (V8192) (cond ((and (cons? V8192) (and (= where (hd V8192)) (and (cons? (tl V8192)) (and (cons? (hd (tl V8192))) (and (= = (hd (hd (tl V8192)))) (and (cons? (tl (hd (tl V8192)))) (and (cons? (tl (tl (hd (tl V8192))))) (and (= () (tl (tl (tl (hd (tl V8192)))))) (and (cons? (tl (tl V8192))) (= () (tl (tl (tl V8192))))))))))))) (cons (cons (if (value shen.*occurs*) is! is) (tl (hd (tl V8192)))) (shen.lchh (hd (tl (tl V8192)))))) (true V8192)))

(defun shen.<clause> (V8193) (let W8194 (let W8195 (shen.<head> V8193) (if (shen.parse-failure? W8195) (shen.parse-failure) (let W8196 (shen.<-out W8195) (let W8197 (shen.in-> W8195) (if (shen.hds=? W8197 <--) (let W8198 (tail W8197) (let W8199 (shen.<body> W8198) (if (shen.parse-failure? W8199) (shen.parse-failure) (let W8200 (shen.<-out W8199) (let W8201 (shen.in-> W8199) (let W8202 (shen.<sc> W8201) (if (shen.parse-failure? W8202) (shen.parse-failure) (let W8203 (shen.in-> W8202) (shen.comb W8203 (cons W8196 (cons W8200 ()))))))))))) (shen.parse-failure)))))) (if (shen.parse-failure? W8194) (shen.parse-failure) W8194)))

(defun shen.<head> (V8204) (let W8205 (let W8206 (shen.<hterm> V8204) (if (shen.parse-failure? W8206) (shen.parse-failure) (let W8207 (shen.<-out W8206) (let W8208 (shen.in-> W8206) (let W8209 (shen.<head> W8208) (if (shen.parse-failure? W8209) (shen.parse-failure) (let W8210 (shen.<-out W8209) (let W8211 (shen.in-> W8209) (shen.comb W8211 (cons W8207 W8210)))))))))) (if (shen.parse-failure? W8205) (let W8212 (let W8213 (<e> V8204) (if (shen.parse-failure? W8213) (shen.parse-failure) (let W8214 (shen.in-> W8213) (shen.comb W8214 ())))) (if (shen.parse-failure? W8212) (shen.parse-failure) W8212)) W8205)))

(defun shen.<hterm> (V8215) (let W8216 (if (cons? V8215) (let W8217 (head V8215) (let W8218 (tail V8215) (if (and (atom? W8217) (not (shen.prolog-keyword? W8217))) (shen.comb W8218 W8217) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8216) (let W8219 (if (cons? V8215) (let W8220 (head V8215) (let W8221 (tail V8215) (if (= W8220 (intern ":")) (shen.comb W8221 W8220) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8219) (let W8222 (if (shen.ccons? V8215) (let W8223 (head V8215) (let W8224 (tail V8215) (if (shen.hds=? W8223 cons) (let W8225 (tail W8223) (let W8226 (shen.<hterm1> W8225) (if (shen.parse-failure? W8226) (shen.parse-failure) (let W8227 (shen.<-out W8226) (let W8228 (shen.in-> W8226) (let W8229 (shen.<hterm2> W8228) (if (shen.parse-failure? W8229) (shen.parse-failure) (let W8230 (shen.<-out W8229) (let W8231 (shen.in-> W8229) (let W8232 (<end> W8231) (if (shen.parse-failure? W8232) (shen.parse-failure) (let W8233 (shen.in-> W8232) (shen.comb W8224 (cons cons (cons W8227 (cons W8230 ())))))))))))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8222) (let W8234 (if (shen.ccons? V8215) (let W8235 (head V8215) (let W8236 (tail V8215) (if (shen.hds=? W8235 +) (let W8237 (tail W8235) (let W8238 (shen.<hterm> W8237) (if (shen.parse-failure? W8238) (shen.parse-failure) (let W8239 (shen.<-out W8238) (let W8240 (shen.in-> W8238) (let W8241 (<end> W8240) (if (shen.parse-failure? W8241) (shen.parse-failure) (let W8242 (shen.in-> W8241) (shen.comb W8236 (cons shen.+m (cons W8239 ()))))))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8234) (let W8243 (if (shen.ccons? V8215) (let W8244 (head V8215) (let W8245 (tail V8215) (if (shen.hds=? W8244 -) (let W8246 (tail W8244) (let W8247 (shen.<hterm> W8246) (if (shen.parse-failure? W8247) (shen.parse-failure) (let W8248 (shen.<-out W8247) (let W8249 (shen.in-> W8247) (let W8250 (<end> W8249) (if (shen.parse-failure? W8250) (shen.parse-failure) (let W8251 (shen.in-> W8250) (shen.comb W8245 (cons shen.-m (cons W8248 ()))))))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8243) (let W8252 (if (shen.ccons? V8215) (let W8253 (head V8215) (let W8254 (tail V8215) (if (shen.hds=? W8253 mode) (let W8255 (tail W8253) (let W8256 (shen.<hterm> W8255) (if (shen.parse-failure? W8256) (shen.parse-failure) (let W8257 (shen.<-out W8256) (let W8258 (shen.in-> W8256) (if (shen.hds=? W8258 +) (let W8259 (tail W8258) (let W8260 (<end> W8259) (if (shen.parse-failure? W8260) (shen.parse-failure) (let W8261 (shen.in-> W8260) (shen.comb W8254 (cons shen.+m (cons W8257 ()))))))) (shen.parse-failure))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8252) (let W8262 (if (shen.ccons? V8215) (let W8263 (head V8215) (let W8264 (tail V8215) (if (shen.hds=? W8263 mode) (let W8265 (tail W8263) (let W8266 (shen.<hterm> W8265) (if (shen.parse-failure? W8266) (shen.parse-failure) (let W8267 (shen.<-out W8266) (let W8268 (shen.in-> W8266) (if (shen.hds=? W8268 -) (let W8269 (tail W8268) (let W8270 (<end> W8269) (if (shen.parse-failure? W8270) (shen.parse-failure) (let W8271 (shen.in-> W8270) (shen.comb W8264 (cons shen.-m (cons W8267 ()))))))) (shen.parse-failure))))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8262) (shen.parse-failure) W8262)) W8252)) W8243)) W8234)) W8222)) W8219)) W8216)))

(defun shen.prolog-keyword? (V8272) (element? V8272 (cons (intern ";") (cons <-- ()))))

(defun atom? (V8273) (or (symbol? V8273) (or (string? V8273) (or (boolean? V8273) (or (number? V8273) (empty? V8273))))))

(defun shen.<hterm1> (V8274) (let W8275 (let W8276 (shen.<hterm> V8274) (if (shen.parse-failure? W8276) (shen.parse-failure) (let W8277 (shen.<-out W8276) (let W8278 (shen.in-> W8276) (shen.comb W8278 W8277))))) (if (shen.parse-failure? W8275) (shen.parse-failure) W8275)))

(defun shen.<hterm2> (V8279) (let W8280 (let W8281 (shen.<hterm> V8279) (if (shen.parse-failure? W8281) (shen.parse-failure) (let W8282 (shen.<-out W8281) (let W8283 (shen.in-> W8281) (shen.comb W8283 W8282))))) (if (shen.parse-failure? W8280) (shen.parse-failure) W8280)))

(defun shen.<body> (V8284) (let W8285 (let W8286 (shen.<literal> V8284) (if (shen.parse-failure? W8286) (shen.parse-failure) (let W8287 (shen.<-out W8286) (let W8288 (shen.in-> W8286) (let W8289 (shen.<body> W8288) (if (shen.parse-failure? W8289) (shen.parse-failure) (let W8290 (shen.<-out W8289) (let W8291 (shen.in-> W8289) (shen.comb W8291 (cons W8287 W8290)))))))))) (if (shen.parse-failure? W8285) (let W8292 (let W8293 (<e> V8284) (if (shen.parse-failure? W8293) (shen.parse-failure) (let W8294 (shen.in-> W8293) (shen.comb W8294 ())))) (if (shen.parse-failure? W8292) (shen.parse-failure) W8292)) W8285)))

(defun shen.<literal> (V8295) (let W8296 (if (shen.hds=? V8295 !) (let W8297 (tail V8295) (shen.comb W8297 !)) (shen.parse-failure)) (if (shen.parse-failure? W8296) (let W8298 (if (shen.ccons? V8295) (let W8299 (head V8295) (let W8300 (tail V8295) (let W8301 (shen.<bterms> W8299) (if (shen.parse-failure? W8301) (shen.parse-failure) (let W8302 (shen.<-out W8301) (let W8303 (shen.in-> W8301) (let W8304 (<end> W8303) (if (shen.parse-failure? W8304) (shen.parse-failure) (let W8305 (shen.in-> W8304) (shen.comb W8300 W8302)))))))))) (shen.parse-failure)) (if (shen.parse-failure? W8298) (shen.parse-failure) W8298)) W8296)))

(defun shen.<bterms> (V8306) (let W8307 (let W8308 (shen.<bterm> V8306) (if (shen.parse-failure? W8308) (shen.parse-failure) (let W8309 (shen.<-out W8308) (let W8310 (shen.in-> W8308) (let W8311 (shen.<bterms> W8310) (if (shen.parse-failure? W8311) (shen.parse-failure) (let W8312 (shen.<-out W8311) (let W8313 (shen.in-> W8311) (shen.comb W8313 (cons W8309 W8312)))))))))) (if (shen.parse-failure? W8307) (let W8314 (let W8315 (<e> V8306) (if (shen.parse-failure? W8315) (shen.parse-failure) (let W8316 (shen.in-> W8315) (shen.comb W8316 ())))) (if (shen.parse-failure? W8314) (shen.parse-failure) W8314)) W8307)))

(defun shen.<bterm> (V8317) (let W8318 (let W8319 (shen.<wildcard> V8317) (if (shen.parse-failure? W8319) (shen.parse-failure) (let W8320 (shen.<-out W8319) (let W8321 (shen.in-> W8319) (shen.comb W8321 W8320))))) (if (shen.parse-failure? W8318) (let W8322 (if (cons? V8317) (let W8323 (head V8317) (let W8324 (tail V8317) (if (atom? W8323) (shen.comb W8324 W8323) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8322) (let W8325 (if (shen.ccons? V8317) (let W8326 (head V8317) (let W8327 (tail V8317) (let W8328 (shen.<bterms> W8326) (if (shen.parse-failure? W8328) (shen.parse-failure) (let W8329 (shen.<-out W8328) (let W8330 (shen.in-> W8328) (let W8331 (<end> W8330) (if (shen.parse-failure? W8331) (shen.parse-failure) (let W8332 (shen.in-> W8331) (shen.comb W8327 W8329)))))))))) (shen.parse-failure)) (if (shen.parse-failure? W8325) (shen.parse-failure) W8325)) W8322)) W8318)))

(defun shen.<wildcard> (V8333) (let W8334 (if (cons? V8333) (let W8335 (head V8333) (let W8336 (tail V8333) (if (= W8335 _) (shen.comb W8336 (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8334) (shen.parse-failure) W8334)))

(defun shen.<sc> (V8337) (let W8338 (if (cons? V8337) (let W8339 (head V8337) (let W8340 (tail V8337) (if (shen.semicolon? W8339) (shen.comb W8340 W8339) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W8338) (shen.parse-failure) W8338)))

(defun shen.semicolon? (V8341) (= V8341 (intern ";")))

(defun shen.horn-clause-procedure (V8342 V8343) (let W8344 (gensym B) (let W8345 (gensym L) (let W8346 (gensym K) (let W8347 (gensym C) (let W8348 (shen.prolog-parameters V8343) (let W8349 (shen.hascut? V8343) (let W8350 (shen.prolog-fbody V8343 W8348 W8344 W8345 W8346 W8347 W8349) (let W8351 (if W8349 (cons let (cons W8346 (cons (cons + (cons W8346 (cons 1 ()))) (cons W8350 ())))) W8350) (let W8352 (cons define (cons V8342 (append W8348 (append (cons W8344 (cons W8345 (cons W8346 (cons W8347 (cons -> ()))))) (cons W8351 ()))))) W8352))))))))))

(defun shen.hascut? (V8355) (cond ((= ! V8355) true) ((cons? V8355) (or (shen.hascut? (hd V8355)) (shen.hascut? (tl V8355)))) (true false)))

(defun shen.prolog-parameters (V8360) (cond ((and (cons? V8360) (cons? (hd V8360))) (shen.parameters (length (hd (hd V8360))))) (true (simple-error "partial function shen.prolog-parameters"))))

(defun shen.prolog-fbody (V8381 V8382 V8383 V8384 V8385 V8386 V8387) (cond ((and (= () V8381) (= true V8387)) (cons shen.unlock (cons V8384 (cons V8385 ())))) ((and (cons? V8381) (and (cons? (hd V8381)) (and (cons? (tl (hd V8381))) (and (= () (tl (tl (hd V8381)))) (and (= () (tl V8381)) (= false V8387)))))) (let W8388 (shen.continue (hd (hd V8381)) (hd (tl (hd V8381))) V8383 V8384 V8385 V8386) (cons if (cons (cons shen.unlocked? (cons V8384 ())) (cons (shen.compile-head shen.+m (hd (hd V8381)) V8382 V8383 W8388) (cons false ())))))) ((and (cons? V8381) (and (cons? (hd V8381)) (and (cons? (tl (hd V8381))) (= () (tl (tl (hd V8381))))))) (let W8389 (gensym C) (let W8390 (shen.continue (hd (hd V8381)) (hd (tl (hd V8381))) V8383 V8384 V8385 V8386) (cons let (cons W8389 (cons (cons if (cons (cons shen.unlocked? (cons V8384 ())) (cons (shen.compile-head shen.+m (hd (hd V8381)) V8382 V8383 W8390) (cons false ())))) (cons (cons if (cons (cons = (cons W8389 (cons false ()))) (cons (shen.prolog-fbody (tl V8381) V8382 V8383 V8384 V8385 V8386 V8387) (cons W8389 ())))) ()))))))) (true (simple-error "implementation error in shen.prolog-fbody"))))

(defun shen.unlock (V8391 V8392) (if (and (shen.locked? V8391) (shen.fits? V8392 V8391)) (shen.openlock V8391) false))

(defun shen.locked? (V8393) (not (shen.unlocked? V8393)))

(defun shen.unlocked? (V8394) (<-address V8394 1))

(defun shen.openlock (V8395) (do (address-> V8395 1 true) false))

(defun shen.fits? (V8396 V8397) (= V8396 (<-address V8397 2)))

(defun shen.cut (V8400 V8401 V8402 V8403) (let W8404 (thaw V8403) (if (and (= W8404 false) (shen.unlocked? V8401)) (shen.lock V8402 V8401) W8404)))

(defun shen.lock (V8405 V8406) (let W8407 (address-> V8406 1 false) (let W8408 (address-> V8406 2 V8405) false)))

(defun shen.continue (V8409 V8410 V8411 V8412 V8413 V8414) (let W8415 (shen.extract-vars V8409) (let W8416 (shen.extract-free-vars V8410) (let W8417 (difference W8416 W8415) (let W8418 (cons do (cons (cons shen.incinfs ()) (cons (shen.compile-body V8410 V8411 V8412 V8413 V8414) ()))) (shen.stpart W8417 W8418 V8411))))))

(defun shen.extract-free-vars (V8421) (cond ((and (cons? V8421) (and (= lambda (hd V8421)) (and (cons? (tl V8421)) (and (cons? (tl (tl V8421))) (= () (tl (tl (tl V8421)))))))) (remove (hd (tl V8421)) (shen.extract-free-vars (hd (tl (tl V8421)))))) ((cons? V8421) (union (shen.extract-free-vars (hd V8421)) (shen.extract-free-vars (tl V8421)))) ((variable? V8421) (cons V8421 ())) (true ())))

(defun shen.compile-body (V8438 V8439 V8440 V8441 V8442) (cond ((= () V8438) (cons thaw (cons V8442 ()))) ((and (cons? V8438) (= ! (hd V8438))) (shen.compile-body (cons (cons shen.cut ()) (tl V8438)) V8439 V8440 V8441 V8442)) ((and (cons? V8438) (= () (tl V8438))) (append (shen.deref-calls (hd V8438) V8439) (cons V8439 (cons V8440 (cons V8441 (cons V8442 ())))))) ((cons? V8438) (let W8443 (shen.deref-calls (hd V8438) V8439) (append W8443 (cons V8439 (cons V8440 (cons V8441 (cons (shen.freeze-literals (tl V8438) V8439 V8440 V8441 V8442) ()))))))) (true (simple-error "implementation error in shen.compile-fbody"))))

(defun shen.freeze-literals (V8460 V8461 V8462 V8463 V8464) (cond ((= () V8460) V8464) ((and (cons? V8460) (= ! (hd V8460))) (shen.freeze-literals (cons (cons shen.cut ()) (tl V8460)) V8461 V8462 V8463 V8464)) ((cons? V8460) (let W8465 (shen.deref-calls (hd V8460) V8461) (cons freeze (cons (append W8465 (cons V8461 (cons V8462 (cons V8463 (cons (shen.freeze-literals (tl V8460) V8461 V8462 V8463 V8464) ()))))) ())))) (true (simple-error "implementation error in shen.freeze-literals"))))

(defun shen.deref-calls (V8470 V8471) (cond ((and (cons? V8470) (= fork (hd V8470))) (cons fork (cons (shen.deref-forked-literals (tl V8470) V8471) ()))) ((cons? V8470) (cons (hd V8470) (map (lambda Z8472 (shen.function-calls Z8472 V8471)) (tl V8470)))) (true (simple-error "implementation error in shen.deref-calls"))))

(defun shen.deref-forked-literals (V8479 V8480) (cond ((= () V8479) ()) ((cons? V8479) (cons cons (cons (shen.deref-calls (hd V8479) V8480) (cons (shen.deref-forked-literals (tl V8479) V8480) ())))) (true (simple-error "fork requires a list of literals
"))))

(defun shen.function-calls (V8483 V8484) (cond ((and (cons? V8483) (and (= cons (hd V8483)) (and (cons? (tl V8483)) (and (cons? (tl (tl V8483))) (= () (tl (tl (tl V8483)))))))) (cons cons (cons (shen.function-calls (hd (tl V8483)) V8484) (cons (shen.function-calls (hd (tl (tl V8483))) V8484) ())))) ((cons? V8483) (shen.deref-terms V8483 V8484 ())) (true V8483)))

(defun shen.deref-terms (V8493 V8494 V8495) (cond ((and (cons? V8493) (and (= 0 (hd V8493)) (and (cons? (tl V8493)) (= () (tl (tl V8493)))))) (if (variable? (hd (tl V8493))) (hd (tl V8493)) (simple-error (cn "attempt to optimise a non-variable " (shen.app (hd (tl V8493)) "
" shen.s))))) ((and (cons? V8493) (and (= 1 (hd V8493)) (and (cons? (tl V8493)) (= () (tl (tl V8493)))))) (if (variable? (hd (tl V8493))) (cons shen.lazyderef (cons (hd (tl V8493)) (cons V8494 ()))) (simple-error (cn "attempt to optimise a non-variable " (shen.app (hd (tl V8493)) "
" shen.s))))) ((and (not (element? V8493 V8495)) (variable? V8493)) (cons shen.deref (cons V8493 (cons V8494 ())))) ((and (cons? V8493) (and (= lambda (hd V8493)) (and (cons? (tl V8493)) (and (cons? (tl (tl V8493))) (= () (tl (tl (tl V8493)))))))) (cons lambda (cons (hd (tl V8493)) (cons (shen.deref-terms (hd (tl (tl V8493))) V8494 (cons (hd (tl V8493)) V8495)) ())))) ((cons? V8493) (map (lambda Z8496 (shen.deref-terms Z8496 V8494 V8495)) V8493)) (true V8493)))

(defun shen.compile-head (V8514 V8515 V8516 V8517 V8518) (cond ((and (= () V8515) (= () V8516)) V8518) ((and (cons? V8515) (and (cons? (hd V8515)) (and (= shen.+m (hd (hd V8515))) (and (cons? (tl (hd V8515))) (= () (tl (tl (hd V8515)))))))) (shen.compile-head V8514 (cons shen.+m (cons (hd (tl (hd V8515))) (cons V8514 (tl V8515)))) V8516 V8517 V8518)) ((and (cons? V8515) (and (cons? (hd V8515)) (and (= shen.-m (hd (hd V8515))) (and (cons? (tl (hd V8515))) (= () (tl (tl (hd V8515)))))))) (shen.compile-head V8514 (cons shen.-m (cons (hd (tl (hd V8515))) (cons V8514 (tl V8515)))) V8516 V8517 V8518)) ((and (cons? V8515) (= shen.-m (hd V8515))) (shen.compile-head shen.-m (tl V8515) V8516 V8517 V8518)) ((and (cons? V8515) (= shen.+m (hd V8515))) (shen.compile-head shen.+m (tl V8515) V8516 V8517 V8518)) ((and (cons? V8515) (and (cons? V8516) (shen.wildcard? (hd V8515)))) (shen.compile-head V8514 (tl V8515) (tl V8516) V8517 V8518)) ((and (cons? V8515) (variable? (hd V8515))) (shen.variable-case V8514 V8515 V8516 V8517 V8518)) ((and (= shen.-m V8514) (and (cons? V8515) (atom? (hd V8515)))) (shen.atom-case-minus V8515 V8516 V8517 V8518)) ((and (= shen.-m V8514) (and (cons? V8515) (and (cons? (hd V8515)) (and (= cons (hd (hd V8515))) (and (cons? (tl (hd V8515))) (and (cons? (tl (tl (hd V8515)))) (= () (tl (tl (tl (hd V8515))))))))))) (shen.cons-case-minus V8515 V8516 V8517 V8518)) ((and (= shen.+m V8514) (and (cons? V8515) (atom? (hd V8515)))) (shen.atom-case-plus V8515 V8516 V8517 V8518)) ((and (= shen.+m V8514) (and (cons? V8515) (and (cons? (hd V8515)) (and (= cons (hd (hd V8515))) (and (cons? (tl (hd V8515))) (and (cons? (tl (tl (hd V8515)))) (= () (tl (tl (tl (hd V8515))))))))))) (shen.cons-case-plus V8515 V8516 V8517 V8518)) (true (simple-error "implementation error in shen.compile-head"))))

(defun shen.variable-case (V8529 V8530 V8531 V8532 V8533) (cond ((and (cons? V8530) (cons? V8531)) (if (variable? (hd V8531)) (shen.compile-head V8529 (tl V8530) (tl V8531) V8532 (subst (hd V8531) (hd V8530) V8533)) (cons let (cons (hd V8530) (cons (hd V8531) (cons (shen.compile-head V8529 (tl V8530) (tl V8531) V8532 V8533) ())))))) (true (simple-error "implementation error in shen.variable-case"))))

(defun shen.atom-case-minus (V8542 V8543 V8544 V8545) (cond ((and (cons? V8542) (cons? V8543)) (let W8546 (gensym Tm) (cons let (cons W8546 (cons (cons shen.lazyderef (cons (hd V8543) (cons V8544 ()))) (cons (cons if (cons (cons = (cons W8546 (cons (hd V8542) ()))) (cons (shen.compile-head shen.-m (tl V8542) (tl V8543) V8544 V8545) (cons false ())))) ())))))) (true (simple-error "implementation error in shen.atom-case-minus"))))

(defun shen.cons-case-minus (V8555 V8556 V8557 V8558) (cond ((and (cons? V8555) (and (cons? (hd V8555)) (and (= cons (hd (hd V8555))) (and (cons? (tl (hd V8555))) (and (cons? (tl (tl (hd V8555)))) (and (= () (tl (tl (tl (hd V8555))))) (cons? V8556))))))) (let W8559 (gensym Tm) (cons let (cons W8559 (cons (cons shen.lazyderef (cons (hd V8556) (cons V8557 ()))) (cons (cons if (cons (cons cons? (cons W8559 ())) (cons (shen.compile-head shen.-m (cons (hd (tl (hd V8555))) (cons (hd (tl (tl (hd V8555)))) (tl V8555))) (cons (cons hd (cons W8559 ())) (cons (cons tl (cons W8559 ())) (tl V8556))) V8557 V8558) (cons false ())))) ())))))) (true (simple-error "implementation error in shen.cons-case-minus"))))

(defun shen.atom-case-plus (V8568 V8569 V8570 V8571) (cond ((and (cons? V8568) (cons? V8569)) (let W8572 (gensym Tm) (let W8573 (gensym GoTo) (cons let (cons W8572 (cons (cons shen.lazyderef (cons (hd V8569) (cons V8570 ()))) (cons W8573 (cons (cons freeze (cons (shen.compile-head shen.+m (tl V8568) (tl V8569) V8570 V8571) ())) (cons (cons if (cons (cons = (cons W8572 (cons (hd V8568) ()))) (cons (cons thaw (cons W8573 ())) (cons (cons if (cons (cons shen.pvar? (cons W8572 ())) (cons (cons shen.bind! (cons W8572 (cons (shen.demode (hd V8568)) (cons V8570 (cons W8573 ()))))) (cons false ())))) ())))) ()))))))))) (true (simple-error "implementation error in shen.atom-case-plus"))))

(defun shen.cons-case-plus (V8582 V8583 V8584 V8585) (cond ((and (cons? V8582) (and (cons? (hd V8582)) (and (= cons (hd (hd V8582))) (and (cons? (tl (hd V8582))) (and (cons? (tl (tl (hd V8582)))) (and (= () (tl (tl (tl (hd V8582))))) (cons? V8583))))))) (let W8586 (gensym Tm) (let W8587 (gensym GoTo) (let W8588 (shen.extract-vars (cons (hd (tl (hd V8582))) (hd (tl (tl (hd V8582)))))) (let W8589 (shen.tame (hd V8582)) (let W8590 (shen.extract-vars W8589) (cons let (cons W8586 (cons (cons shen.lazyderef (cons (hd V8583) (cons V8584 ()))) (cons W8587 (cons (shen.goto W8588 (shen.compile-head shen.+m (tl V8582) (tl V8583) V8584 V8585)) (cons (cons if (cons (cons cons? (cons W8586 ())) (cons (shen.compile-head shen.+m (tl (hd V8582)) (cons (cons hd (cons W8586 ())) (cons (cons tl (cons W8586 ())) ())) V8584 (shen.invoke W8587 W8588)) (cons (cons if (cons (cons shen.pvar? (cons W8586 ())) (cons (shen.stpart W8590 (cons shen.bind! (cons W8586 (cons (shen.demode W8589) (cons V8584 (cons (cons freeze (cons (shen.invoke W8587 W8588) ())) ()))))) V8584) (cons false ())))) ())))) ())))))))))))) (true (simple-error "implementation error in shen.cons-case-plus"))))

(defun shen.demode (V8591) (cond ((and (cons? V8591) (and (= shen.+m (hd V8591)) (and (cons? (tl V8591)) (= () (tl (tl V8591)))))) (shen.demode (hd (tl V8591)))) ((and (cons? V8591) (and (= shen.-m (hd V8591)) (and (cons? (tl V8591)) (= () (tl (tl V8591)))))) (shen.demode (hd (tl V8591)))) ((cons? V8591) (map (lambda Z8592 (shen.demode Z8592)) V8591)) (true V8591)))

(defun shen.tame (V8593) (cond ((shen.wildcard? V8593) (gensym Y)) ((cons? V8593) (map (lambda Z8594 (shen.tame Z8594)) V8593)) (true V8593)))

(defun shen.goto (V8595 V8596) (cond ((= () V8595) (cons freeze (cons V8596 ()))) (true (shen.goto-h V8595 V8596))))

(defun shen.goto-h (V8597 V8598) (cond ((= () V8597) V8598) ((cons? V8597) (cons lambda (cons (hd V8597) (cons (shen.goto-h (tl V8597) V8598) ())))) (true (simple-error "partial function shen.goto-h"))))

(defun shen.invoke (V8599 V8600) (cond ((= () V8600) (cons thaw (cons V8599 ()))) (true (cons V8599 V8600))))

(defun shen.wildcard? (V8601) (= V8601 _))

(defun shen.pvar? (V8602) (trap-error (and (absvector? V8602) (= (<-address V8602 0) shen.pvar)) (lambda Z8603 false)))

(defun shen.lazyderef (V8604 V8605) (if (shen.pvar? V8604) (let W8606 (<-address V8605 (<-address V8604 1)) (if (= W8606 shen.-null-) V8604 (shen.lazyderef W8606 V8605))) V8604))

(defun shen.deref (V8607 V8608) (cond ((cons? V8607) (cons (shen.deref (hd V8607) V8608) (shen.deref (tl V8607) V8608))) (true (if (shen.pvar? V8607) (let W8609 (<-address V8608 (<-address V8607 1)) (if (= W8609 shen.-null-) V8607 (shen.deref W8609 V8608))) V8607))))

(defun shen.bind! (V8610 V8611 V8612 V8613) (let W8614 (shen.bindv V8610 V8611 V8612) (let W8615 (thaw V8613) (if (= W8615 false) (shen.unwind V8610 V8612 W8615) W8615))))

(defun shen.bindv (V8616 V8617 V8618) (address-> V8618 (<-address V8616 1) V8617))

(defun shen.unwind (V8619 V8620 V8621) (do (address-> V8620 (<-address V8619 1) shen.-null-) V8621))

(defun shen.stpart (V8630 V8631 V8632) (cond ((= () V8630) V8631) ((cons? V8630) (cons let (cons (hd V8630) (cons (cons shen.newpv (cons V8632 ())) (cons (cons shen.gc (cons V8632 (cons (shen.stpart (tl V8630) V8631 V8632) ()))) ()))))) (true (simple-error "implementation error in shen.stpart"))))

(defun shen.gc (V8633 V8634) (if (= V8634 false) (let W8635 (shen.ticket-number V8633) (do (shen.decrement-ticket W8635 V8633) V8634)) V8634))

(defun shen.decrement-ticket (V8636 V8637) (address-> V8637 1 (- V8636 1)))

(defun shen.newpv (V8638) (let W8639 (shen.ticket-number V8638) (let W8640 (shen.make-prolog-variable W8639) (let W8641 (shen.nextticket V8638 W8639) W8640))))

(defun shen.ticket-number (V8642) (<-address V8642 1))

(defun shen.nextticket (V8643 V8644) (let W8645 (address-> V8643 V8644 shen.-null-) (address-> W8645 1 (+ V8644 1))))

(defun shen.make-prolog-variable (V8646) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V8646))

(defun shen.pvar (V8647) (cn "Var" (shen.app (<-address V8647 1) "" shen.a)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.prolog-vector-size (V8648) (if (and (integer? V8648) (> V8648 0)) (set shen.*size-prolog-vector* V8648) (simple-error (cn "prolog vector size: size should be a positive integer; not " (shen.app V8648 "" shen.a)))))

(defun shen.lzy=! (V8660 V8661 V8662 V8663) (cond ((= V8660 V8661) (thaw V8663)) ((and (shen.pvar? V8660) (not (shen.occurs? V8660 (shen.deref V8661 V8662)))) (shen.bind! V8660 V8661 V8662 V8663)) ((and (shen.pvar? V8661) (not (shen.occurs? V8661 (shen.deref V8660 V8662)))) (shen.bind! V8661 V8660 V8662 V8663)) ((and (cons? V8660) (cons? V8661)) (shen.lzy=! (shen.lazyderef (hd V8660) V8662) (shen.lazyderef (hd V8661) V8662) V8662 (freeze (shen.lzy=! (shen.lazyderef (tl V8660) V8662) (shen.lazyderef (tl V8661) V8662) V8662 V8663)))) (true false)))

(defun shen.lzy= (V8675 V8676 V8677 V8678) (cond ((= V8675 V8676) (thaw V8678)) ((shen.pvar? V8675) (shen.bind! V8675 V8676 V8677 V8678)) ((shen.pvar? V8676) (shen.bind! V8676 V8675 V8677 V8678)) ((and (cons? V8675) (cons? V8676)) (shen.lzy= (shen.lazyderef (hd V8675) V8677) (shen.lazyderef (hd V8676) V8677) V8677 (freeze (shen.lzy= (shen.lazyderef (tl V8675) V8677) (shen.lazyderef (tl V8676) V8677) V8677 V8678)))) (true false)))

(defun shen.occurs? (V8684 V8685) (cond ((= V8684 V8685) true) ((cons? V8685) (or (shen.occurs? V8684 (hd V8685)) (shen.occurs? V8684 (tl V8685)))) (true false)))

(defun call (V8686 V8687 V8688 V8689 V8690) ((((V8686 V8687) V8688) V8689) V8690))

(defun return (V8697 V8698 V8699 V8700 V8701) (shen.deref V8697 V8698))

(defun when (V8708 V8709 V8710 V8711 V8712) (if V8708 (thaw V8712) false))

(defun is (V8713 V8714 V8715 V8716 V8717 V8718) (shen.lzy= (shen.lazyderef V8713 V8715) (shen.lazyderef V8714 V8715) V8715 V8718))

(defun is! (V8719 V8720 V8721 V8722 V8723 V8724) (shen.lzy=! (shen.lazyderef V8719 V8721) (shen.lazyderef V8720 V8721) V8721 V8724))

(defun bind (V8729 V8730 V8731 V8732 V8733 V8734) (shen.bind! V8729 V8730 V8731 V8734))

(defun var? (V8735 V8736 V8737 V8738 V8739) (if (shen.pvar? (shen.lazyderef V8735 V8736)) (thaw V8739) false))

(defun shen.print-prolog-vector (V8742) "|prolog vector|")

(defun fork (V8761 V8762 V8763 V8764 V8765) (cond ((= () V8761) false) ((cons? V8761) (let W8766 (((((hd V8761) V8762) V8763) V8764) V8765) (if (= W8766 false) (fork (tl V8761) V8762 V8763 V8764 V8765) W8766))) (true (simple-error "fork expects a list of literals
"))))

(defun findall (V8767 V8768 V8769 V8770 V8771 V8772 V8773) (if (shen.unlocked? V8771) (let W8774 (shen.newpv V8770) (shen.gc V8770 (do (shen.incinfs) (is W8774 () V8770 V8771 V8772 (freeze (shen.findall-h V8767 V8768 V8769 W8774 V8770 V8771 V8772 V8773)))))) false))

(defun shen.findall-h (V8775 V8776 V8777 V8778 V8779 V8780 V8781 V8782) (let W8783 (if (shen.unlocked? V8780) (do (shen.incinfs) (call V8776 V8779 V8780 V8781 (freeze (shen.overbind V8775 V8778 V8779 V8780 V8781 V8782)))) false) (if (= W8783 false) (if (shen.unlocked? V8780) (do (shen.incinfs) (is! V8777 V8778 V8779 V8780 V8781 V8782)) false) W8783)))

(defun shen.overbind (V8790 V8791 V8792 V8793 V8794 V8795) (do (shen.bindv V8791 (cons (shen.deref V8790 V8792) (shen.lazyderef V8791 V8792)) V8792) false))

(defun occurs-check (V8798) (cond ((= + V8798) (set shen.*occurs* true)) ((= - V8798) (set shen.*occurs* false)) (true (simple-error "occurs-check expects a + or a -.
"))))

