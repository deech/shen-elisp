(defun macroexpand (V7730) (let W7731 (map (lambda Z7732 (tl Z7732)) (value *macros*)) (shen.macroexpand-h V7730 W7731 W7731)))

(defun shen.macroexpand-h (V7741 V7742 V7743) (cond ((= () V7742) V7741) ((cons? V7742) (let W7744 (shen.walk (hd V7742) V7741) (if (= V7741 W7744) (shen.macroexpand-h V7741 (tl V7742) V7743) (shen.macroexpand-h W7744 V7743 V7743)))) (true (simple-error "implementation error in shen.macroexpand-h"))))

(defun shen.walk (V7745 V7746) (cond ((cons? V7746) (V7745 (map (lambda Z7747 (shen.walk V7745 Z7747)) V7746))) (true (V7745 V7746))))

(defun shen.defmacro-macro (V7748) (cond ((and (cons? V7748) (and (= defmacro (hd V7748)) (cons? (tl V7748)))) (let W7749 (cons X (cons -> (cons X ()))) (let W7750 (eval (cons define (cons (hd (tl V7748)) (append (tl (tl V7748)) W7749)))) (let W7751 (shen.record-macro (hd (tl V7748)) (lambda Z7752 ((hd (tl V7748)) Z7752))) (hd (tl V7748)))))) (true V7748)))

(defun shen.u!-macro (V7753) (cond ((and (cons? V7753) (and (= u! (hd V7753)) (and (cons? (tl V7753)) (= () (tl (tl V7753)))))) (cons protect (cons (shen.make-uppercase (hd (tl V7753))) ()))) (true V7753)))

(defun shen.make-uppercase (V7754) (intern (shen.mu-h (str V7754))))

(defun shen.mu-h (V7755) (cond ((= "" V7755) "") ((shen.+string? V7755) (let W7756 (string->n (hdstr V7755)) (let W7757 (- W7756 32) (let W7758 (if (and (>= W7756 97) (<= W7756 122)) (n->string W7757) (hdstr V7755)) (@s W7758 (shen.mu-h (tlstr V7755))))))) (true (simple-error "partial function shen.mu-h"))))

(defun shen.record-macro (V7759 V7760) (set *macros* (shen.update-assoc V7759 V7760 (value *macros*))))

(defun shen.update-assoc (V7770 V7771 V7772) (cond ((= () V7772) (cons (cons V7770 V7771) ())) ((and (cons? V7772) (and (cons? (hd V7772)) (= V7770 (hd (hd V7772))))) (cons (cons (hd (hd V7772)) V7771) (tl V7772))) ((cons? V7772) (cons (hd V7772) (shen.update-assoc V7770 V7771 (tl V7772)))) (true (simple-error "implementation error in shen.update-assoc"))))

(defun shen.error-macro (V7773) (cond ((and (cons? V7773) (and (= error (hd V7773)) (cons? (tl V7773)))) (cons simple-error (cons (shen.mkstr (hd (tl V7773)) (tl (tl V7773))) ()))) (true V7773)))

(defun shen.output-macro (V7774) (cond ((and (cons? V7774) (and (= output (hd V7774)) (cons? (tl V7774)))) (cons pr (cons (shen.mkstr (hd (tl V7774)) (tl (tl V7774))) (cons (cons stoutput ()) ())))) ((and (cons? V7774) (and (= pr (hd V7774)) (and (cons? (tl V7774)) (= () (tl (tl V7774)))))) (cons pr (cons (hd (tl V7774)) (cons (cons stoutput ()) ())))) (true V7774)))

(defun shen.make-string-macro (V7775) (cond ((and (cons? V7775) (and (= make-string (hd V7775)) (cons? (tl V7775)))) (shen.mkstr (hd (tl V7775)) (tl (tl V7775)))) (true V7775)))

(defun shen.input-macro (V7776) (cond ((and (cons? V7776) (and (= lineread (hd V7776)) (= () (tl V7776)))) (cons lineread (cons (cons stinput ()) ()))) ((and (cons? V7776) (and (= input (hd V7776)) (= () (tl V7776)))) (cons input (cons (cons stinput ()) ()))) ((and (cons? V7776) (and (= read (hd V7776)) (= () (tl V7776)))) (cons read (cons (cons stinput ()) ()))) ((and (cons? V7776) (and (= input+ (hd V7776)) (and (cons? (tl V7776)) (= () (tl (tl V7776)))))) (cons input+ (cons (hd (tl V7776)) (cons (cons stinput ()) ())))) ((and (cons? V7776) (and (= read-byte (hd V7776)) (= () (tl V7776)))) (if (shen.char-stinput? (stinput)) (cons string->n (cons (cons shen.read-unit-string (cons (cons stinput ()) ())) ())) (cons read-byte (cons (cons stinput ()) ())))) (true V7776)))

(defun shen.defcc-macro (V7777) (cond ((and (cons? V7777) (= defcc (hd V7777))) (shen.yacc->shen (tl V7777))) (true V7777)))

(defun shen.prolog-macro (V7778) (cond ((and (cons? V7778) (= prolog? (hd V7778))) (shen.call-prolog (tl V7778))) (true V7778)))

(defun shen.call-prolog (V7779) (let W7780 (cons shen.reset-prolog-vector ()) (let W7781 (cons @v (cons true (cons 0 (cons (cons vector (cons 0 ())) ())))) (let W7782 0 (let W7783 (cons freeze (cons true ())) (let W7784 (compile (lambda Z7785 (shen.<body> Z7785)) V7779) (let W7786 (shen.received V7779) (let W7787 (gensym V) (let W7788 (gensym L) (let W7789 (gensym K) (let W7790 (gensym C) (let W7791 (cons lambda (cons W7787 (cons (cons lambda (cons W7788 (cons (cons lambda (cons W7789 (cons (cons lambda (cons W7790 (cons (shen.continue W7786 W7784 W7787 W7788 W7789 W7790) ()))) ()))) ()))) ()))) (cons W7791 (cons W7780 (cons W7781 (cons W7782 (cons W7783 ())))))))))))))))))

(defun shen.received (V7794) (cond ((and (cons? V7794) (and (= receive (hd V7794)) (and (cons? (tl V7794)) (= () (tl (tl V7794)))))) (tl V7794)) ((cons? V7794) (union (shen.received (hd V7794)) (shen.received (tl V7794)))) (true ())))

(defun shen.reset-prolog-vector () (address-> (value shen.*prolog-vector*) 1 2))

(defun receive (V7795) V7795)

(defun shen.defprolog-macro (V7796) (cond ((and (cons? V7796) (and (= defprolog (hd V7796)) (cons? (tl V7796)))) (shen.compile-prolog (hd (tl V7796)) (tl (tl V7796)))) (true V7796)))

(defun shen.datatype-macro (V7797) (cond ((and (cons? V7797) (and (= datatype (hd V7797)) (cons? (tl V7797)))) (let W7798 (shen.intern-type (hd (tl V7797))) (let W7799 (compile (lambda Z7800 (shen.<datatype> Z7800)) (cons W7798 (tl (tl V7797)))) W7798))) (true V7797)))

(defun shen.rcons_form (V7801) (cond ((cons? V7801) (cons cons (cons (shen.rcons_form (hd V7801)) (cons (shen.rcons_form (tl V7801)) ())))) (true V7801)))

(defun shen.intern-type (V7802) (intern (cn (str V7802) "#type")))

(defun shen.@s-macro (V7803) (cond ((and (cons? V7803) (and (= @s (hd V7803)) (and (cons? (tl V7803)) (and (cons? (tl (tl V7803))) (cons? (tl (tl (tl V7803)))))))) (cons @s (cons (hd (tl V7803)) (cons (shen.@s-macro (cons @s (tl (tl V7803)))) ())))) ((and (cons? V7803) (and (= @s (hd V7803)) (and (cons? (tl V7803)) (and (cons? (tl (tl V7803))) (and (= () (tl (tl (tl V7803)))) (string? (hd (tl V7803)))))))) (let W7804 (explode (hd (tl V7803))) (if (> (length W7804) 1) (shen.@s-macro (cons @s (append W7804 (tl (tl V7803))))) V7803))) (true V7803)))

(defun shen.synonyms-macro (V7805) (cond ((and (cons? V7805) (= synonyms (hd V7805))) (shen.synonyms-h (set shen.*synonyms* (append (tl V7805) (value shen.*synonyms*))))) (true V7805)))

(defun shen.synonyms-h (V7806) (let W7807 (map (lambda Z7808 (shen.curry-type Z7808)) V7806) (let W7809 (eval (cons define (cons shen.demod (shen.compile-synonyms W7807)))) synonyms)))

(defun shen.compile-synonyms (V7812) (cond ((= () V7812) (let W7813 (gensym X) (cons W7813 (cons -> (cons W7813 ()))))) ((and (cons? V7812) (cons? (tl V7812))) (cons (shen.rcons_form (hd V7812)) (cons -> (cons (shen.rcons_form (hd (tl V7812))) (shen.compile-synonyms (tl (tl V7812))))))) (true (simple-error "synonyms requires an even number of arguments
"))))

(defun shen.nl-macro (V7814) (cond ((and (cons? V7814) (and (= nl (hd V7814)) (= () (tl V7814)))) (cons nl (cons 1 ()))) (true V7814)))

(defun shen.assoc-macro (V7815) (cond ((and (cons? V7815) (and (cons? (tl V7815)) (and (cons? (tl (tl V7815))) (and (cons? (tl (tl (tl V7815)))) (element? (hd V7815) (cons @p (cons @v (cons append (cons and (cons or (cons + (cons * (cons do ()))))))))))))) (cons (hd V7815) (cons (hd (tl V7815)) (cons (shen.assoc-macro (cons (hd V7815) (tl (tl V7815)))) ())))) (true V7815)))

(defun shen.let-macro (V7816) (cond ((and (cons? V7816) (and (= let (hd V7816)) (and (cons? (tl V7816)) (and (cons? (tl (tl V7816))) (and (cons? (tl (tl (tl V7816)))) (cons? (tl (tl (tl (tl V7816)))))))))) (cons let (cons (hd (tl V7816)) (cons (hd (tl (tl V7816))) (cons (shen.let-macro (cons let (tl (tl (tl V7816))))) ()))))) ((and (cons? V7816) (and (= let (hd V7816)) (and (cons? (tl V7816)) (and (cons? (tl (tl V7816))) (and (cons? (tl (tl (tl V7816)))) (= () (tl (tl (tl (tl V7816)))))))))) (if (variable? (hd (tl V7816))) V7816 (simple-error (shen.app (hd (tl V7816)) " is not a variable
" shen.s)))) (true V7816)))

(defun shen.abs-macro (V7817) (cond ((and (cons? V7817) (and (= /. (hd V7817)) (and (cons? (tl V7817)) (and (cons? (tl (tl V7817))) (cons? (tl (tl (tl V7817)))))))) (cons lambda (cons (hd (tl V7817)) (cons (shen.abs-macro (cons /. (tl (tl V7817)))) ())))) ((and (cons? V7817) (and (= /. (hd V7817)) (and (cons? (tl V7817)) (and (cons? (tl (tl V7817))) (= () (tl (tl (tl V7817)))))))) (if (variable? (hd (tl V7817))) (cons lambda (tl V7817)) (simple-error (shen.app (hd (tl V7817)) " is not a variable
" shen.s)))) (true V7817)))

(defun shen.cases-macro (V7820) (cond ((and (cons? V7820) (and (= cases (hd V7820)) (and (cons? (tl V7820)) (and (= true (hd (tl V7820))) (cons? (tl (tl V7820))))))) (hd (tl (tl V7820)))) ((and (cons? V7820) (and (= cases (hd V7820)) (and (cons? (tl V7820)) (and (cons? (tl (tl V7820))) (= () (tl (tl (tl V7820)))))))) (cons if (cons (hd (tl V7820)) (cons (hd (tl (tl V7820))) (cons (cons simple-error (cons "error: cases exhausted" ())) ()))))) ((and (cons? V7820) (and (= cases (hd V7820)) (and (cons? (tl V7820)) (cons? (tl (tl V7820)))))) (cons if (cons (hd (tl V7820)) (cons (hd (tl (tl V7820))) (cons (shen.cases-macro (cons cases (tl (tl (tl V7820))))) ()))))) ((and (cons? V7820) (and (= cases (hd V7820)) (and (cons? (tl V7820)) (= () (tl (tl V7820)))))) (simple-error "error: odd number of case elements
")) (true V7820)))

(defun shen.timer-macro (V7821) (cond ((and (cons? V7821) (and (= time (hd V7821)) (and (cons? (tl V7821)) (= () (tl (tl V7821)))))) (shen.let-macro (cons let (cons Start (cons (cons get-time (cons run ())) (cons Result (cons (hd (tl V7821)) (cons Finish (cons (cons get-time (cons run ())) (cons Time (cons (cons - (cons Finish (cons Start ()))) (cons Message (cons (cons pr (cons (cons cn (cons "
run time: " (cons (cons cn (cons (cons str (cons Time ())) (cons " secs
" ()))) ()))) (cons (cons stoutput ()) ()))) (cons Result ())))))))))))))) (true V7821)))

(defun shen.tuple-up (V7822) (cond ((cons? V7822) (cons @p (cons (hd V7822) (cons (shen.tuple-up (tl V7822)) ())))) (true V7822)))

(defun shen.put/get-macro (V7823) (cond ((and (cons? V7823) (and (= put (hd V7823)) (and (cons? (tl V7823)) (and (cons? (tl (tl V7823))) (and (cons? (tl (tl (tl V7823)))) (= () (tl (tl (tl (tl V7823)))))))))) (cons put (cons (hd (tl V7823)) (cons (hd (tl (tl V7823))) (cons (hd (tl (tl (tl V7823)))) (cons (cons value (cons *property-vector* ())) ())))))) ((and (cons? V7823) (and (= get (hd V7823)) (and (cons? (tl V7823)) (and (cons? (tl (tl V7823))) (= () (tl (tl (tl V7823)))))))) (cons get (cons (hd (tl V7823)) (cons (hd (tl (tl V7823))) (cons (cons value (cons *property-vector* ())) ()))))) ((and (cons? V7823) (and (= unput (hd V7823)) (and (cons? (tl V7823)) (and (cons? (tl (tl V7823))) (= () (tl (tl (tl V7823)))))))) (cons unput (cons (hd (tl V7823)) (cons (hd (tl (tl V7823))) (cons (cons value (cons *property-vector* ())) ()))))) (true V7823)))

(defun undefmacro (V7824) (do (set *macros* (remove (assoc V7824 (value *macros*)) (value *macros*))) V7824))

