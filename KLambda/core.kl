(defun shen.shen->kl (V503) (let W504 (shen.shen->kl-h V503) (shen.record-and-evaluate W504)))

(defun shen.record-and-evaluate (V505) (cond ((and (cons? V505) (and (= defun (hd V505)) (and (cons? (tl V505)) (and (cons? (tl (tl V505))) (and (cons? (tl (tl (tl V505)))) (= () (tl (tl (tl (tl V505)))))))))) (let W506 (if (shen.sysfunc? (hd (tl V505))) (simple-error (shen.app (hd (tl V505)) " is not a legitimate function name
" shen.a)) shen.skip) (let W507 (shen.store-arity (hd (tl V505)) (length (hd (tl (tl V505))))) (let W508 (shen.record-kl (hd (tl V505)) V505) (let W509 (eval-kl V505) (shen.fn-print (hd (tl V505)))))))) (true V505)))

(defun shen.shen->kl-h (V510) (cond ((and (cons? V510) (and (= define (hd V510)) (cons? (tl V510)))) (shen.shendef->kldef (hd (tl V510)) (tl (tl V510)))) ((and (cons? V510) (and (= defun (hd V510)) (and (cons? (tl V510)) (and (cons? (tl (tl V510))) (and (cons? (tl (tl (tl V510)))) (= () (tl (tl (tl (tl V510)))))))))) V510) ((and (cons? V510) (and (= type (hd V510)) (and (cons? (tl V510)) (and (cons? (tl (tl V510))) (= () (tl (tl (tl V510)))))))) (cons type (cons (hd (tl V510)) (cons (shen.rcons_form (hd (tl (tl V510)))) ())))) ((and (cons? V510) (and (= input+ (hd V510)) (and (cons? (tl V510)) (and (cons? (tl (tl V510))) (= () (tl (tl (tl V510)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V510))) (tl (tl V510))))) ((cons? V510) (map (lambda Z511 (shen.shen->kl-h Z511)) V510)) (true V510)))

(defun shen.shendef->kldef (V512 V513) (compile (lambda Z514 (shen.<define> Z514)) (cons V512 V513)))

(defun shen.<define> (V515) (let W516 (let W517 (shen.<name> V515) (if (shen.parse-failure? W517) (shen.parse-failure) (let W518 (shen.<-out W517) (let W519 (shen.in-> W517) (if (shen.hds=? W519 {) (let W520 (tail W519) (let W521 (shen.<signature> W520) (if (shen.parse-failure? W521) (shen.parse-failure) (let W522 (shen.in-> W521) (if (shen.hds=? W522 }) (let W523 (tail W522) (let W524 (shen.<rules> W523) (if (shen.parse-failure? W524) (shen.parse-failure) (let W525 (shen.<-out W524) (let W526 (shen.in-> W524) (shen.comb W526 (shen.shendef->kldef-h W518 W525))))))) (shen.parse-failure)))))) (shen.parse-failure)))))) (if (shen.parse-failure? W516) (let W527 (let W528 (shen.<name> V515) (if (shen.parse-failure? W528) (shen.parse-failure) (let W529 (shen.<-out W528) (let W530 (shen.in-> W528) (let W531 (shen.<rules> W530) (if (shen.parse-failure? W531) (shen.parse-failure) (let W532 (shen.<-out W531) (let W533 (shen.in-> W531) (shen.comb W533 (shen.shendef->kldef-h W529 W532)))))))))) (if (shen.parse-failure? W527) (shen.parse-failure) W527)) W516)))

(defun shen.shendef->kldef-h (V534 V535) (let W536 (map (lambda Z537 (fst Z537)) V535) (let W538 (shen.arity-chk V534 W536) (let W539 (map (lambda Z540 (shen.free-var-chk V534 Z540)) V535) (let W541 (shen.unprotect V535) (let W542 (shen.factorise-code (shen.compile-to-kl V534 W541 W538)) W542))))))

(defun shen.unprotect (V543) (cond ((tuple? V543) (@p (shen.unprotect (fst V543)) (shen.unprotect (snd V543)))) ((and (cons? V543) (and (= protect (hd V543)) (and (cons? (tl V543)) (= () (tl (tl V543)))))) (shen.unprotect (hd (tl V543)))) ((cons? V543) (map (lambda Z544 (shen.unprotect Z544)) V543)) (true V543)))

(defun shen.<name> (V545) (let W546 (if (cons? V545) (let W547 (head V545) (let W548 (tail V545) (shen.comb W548 (if (and (symbol? W547) (not (variable? W547))) W547 (simple-error (shen.app W547 " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? W546) (shen.parse-failure) W546)))

(defun shen.<signature> (V549) (let W550 (if (cons? V549) (let W551 (head V549) (let W552 (tail V549) (let W553 (shen.<signature> W552) (if (shen.parse-failure? W553) (shen.parse-failure) (let W554 (shen.<-out W553) (let W555 (shen.in-> W553) (if (not (element? W551 (cons { (cons } ())))) (shen.comb W555 (cons W551 W554)) (shen.parse-failure)))))))) (shen.parse-failure)) (if (shen.parse-failure? W550) (let W556 (let W557 (<e> V549) (if (shen.parse-failure? W557) (shen.parse-failure) (let W558 (shen.in-> W557) (shen.comb W558 ())))) (if (shen.parse-failure? W556) (shen.parse-failure) W556)) W550)))

(defun shen.<rules> (V559) (let W560 (let W561 (shen.<rule> V559) (if (shen.parse-failure? W561) (shen.parse-failure) (let W562 (shen.<-out W561) (let W563 (shen.in-> W561) (let W564 (shen.<rules> W563) (if (shen.parse-failure? W564) (shen.parse-failure) (let W565 (shen.<-out W564) (let W566 (shen.in-> W564) (shen.comb W566 (cons (shen.linearise W562) W565)))))))))) (if (shen.parse-failure? W560) (let W567 (let W568 (<!> V559) (if (shen.parse-failure? W568) (shen.parse-failure) (let W569 (shen.<-out W568) (let W570 (shen.in-> W568) (shen.comb W570 (if (empty? W569) () (simple-error (cn "Shen syntax error here:
 " (shen.app W569 "
 ..." shen.r))))))))) (if (shen.parse-failure? W567) (shen.parse-failure) W567)) W560)))

(defun shen.linearise (V573) (cond ((tuple? V573) (shen.linearise-h (fst V573) (fst V573) () (snd V573))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V586 V587 V588 V589) (cond ((= () V586) (@p V587 V589)) ((and (cons? V586) (cons? (hd V586))) (shen.linearise-h (append (hd V586) (tl V586)) V587 V588 V589)) ((and (cons? V586) (variable? (hd V586))) (if (element? (hd V586) V588) (let W590 (gensym V) (shen.linearise-h (tl V586) (shen.rep-X (hd V586) W590 V587) V588 (cons where (cons (cons = (cons W590 (cons (hd V586) ()))) (cons V589 ()))))) (shen.linearise-h (tl V586) V587 (cons (hd V586) V588) V589))) ((cons? V586) (shen.linearise-h (tl V586) V587 V588 V589)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V591) (let W592 (let W593 (shen.<patterns> V591) (if (shen.parse-failure? W593) (shen.parse-failure) (let W594 (shen.<-out W593) (let W595 (shen.in-> W593) (if (shen.hds=? W595 ->) (let W596 (tail W595) (if (cons? W596) (let W597 (head W596) (let W598 (tail W596) (if (shen.hds=? W598 where) (let W599 (tail W598) (if (cons? W599) (let W600 (head W599) (let W601 (tail W599) (shen.comb W601 (@p W594 (cons where (cons W600 (cons W597 ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))))) (if (shen.parse-failure? W592) (let W602 (let W603 (shen.<patterns> V591) (if (shen.parse-failure? W603) (shen.parse-failure) (let W604 (shen.<-out W603) (let W605 (shen.in-> W603) (if (shen.hds=? W605 ->) (let W606 (tail W605) (if (cons? W606) (let W607 (head W606) (let W608 (tail W606) (shen.comb W608 (@p W604 W607)))) (shen.parse-failure))) (shen.parse-failure)))))) (if (shen.parse-failure? W602) (let W609 (let W610 (shen.<patterns> V591) (if (shen.parse-failure? W610) (shen.parse-failure) (let W611 (shen.<-out W610) (let W612 (shen.in-> W610) (if (shen.hds=? W612 <-) (let W613 (tail W612) (if (cons? W613) (let W614 (head W613) (let W615 (tail W613) (if (shen.hds=? W615 where) (let W616 (tail W615) (if (cons? W616) (let W617 (head W616) (let W618 (tail W616) (shen.comb W618 (@p W611 (cons where (cons W617 (cons (cons shen.choicepoint! (cons W614 ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))))) (if (shen.parse-failure? W609) (let W619 (let W620 (shen.<patterns> V591) (if (shen.parse-failure? W620) (shen.parse-failure) (let W621 (shen.<-out W620) (let W622 (shen.in-> W620) (if (shen.hds=? W622 <-) (let W623 (tail W622) (if (cons? W623) (let W624 (head W623) (let W625 (tail W623) (shen.comb W625 (@p W621 (cons shen.choicepoint! (cons W624 ())))))) (shen.parse-failure))) (shen.parse-failure)))))) (if (shen.parse-failure? W619) (shen.parse-failure) W619)) W609)) W602)) W592)))

(defun shen.<patterns> (V626) (let W627 (let W628 (shen.<pattern> V626) (if (shen.parse-failure? W628) (shen.parse-failure) (let W629 (shen.<-out W628) (let W630 (shen.in-> W628) (let W631 (shen.<patterns> W630) (if (shen.parse-failure? W631) (shen.parse-failure) (let W632 (shen.<-out W631) (let W633 (shen.in-> W631) (shen.comb W633 (cons W629 W632)))))))))) (if (shen.parse-failure? W627) (let W634 (let W635 (<e> V626) (if (shen.parse-failure? W635) (shen.parse-failure) (let W636 (shen.in-> W635) (shen.comb W636 ())))) (if (shen.parse-failure? W634) (shen.parse-failure) W634)) W627)))

(defun shen.<pattern> (V637) (let W638 (if (shen.ccons? V637) (let W639 (head V637) (let W640 (tail V637) (let W641 (shen.<constructor> W639) (if (shen.parse-failure? W641) (shen.parse-failure) (let W642 (shen.<-out W641) (let W643 (shen.in-> W641) (let W644 (shen.<pattern1> W643) (if (shen.parse-failure? W644) (shen.parse-failure) (let W645 (shen.<-out W644) (let W646 (shen.in-> W644) (let W647 (shen.<pattern2> W646) (if (shen.parse-failure? W647) (shen.parse-failure) (let W648 (shen.<-out W647) (let W649 (shen.in-> W647) (let W650 (<end> W649) (if (shen.parse-failure? W650) (shen.parse-failure) (let W651 (shen.in-> W650) (shen.comb W640 (cons W642 (cons W645 (cons W648 ()))))))))))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? W638) (let W652 (if (shen.ccons? V637) (let W653 (head V637) (let W654 (tail V637) (if (shen.hds=? W653 vector) (let W655 (tail W653) (if (shen.hds=? W655 0) (let W656 (tail W655) (let W657 (<end> W656) (if (shen.parse-failure? W657) (shen.parse-failure) (let W658 (shen.in-> W657) (shen.comb W654 (cons vector (cons 0 ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W652) (let W659 (if (cons? V637) (let W660 (head V637) (let W661 (tail V637) (if (cons? W660) (shen.comb W661 (shen.constructor-error W660)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W659) (let W662 (let W663 (shen.<simple-pattern> V637) (if (shen.parse-failure? W663) (shen.parse-failure) (let W664 (shen.<-out W663) (let W665 (shen.in-> W663) (shen.comb W665 W664))))) (if (shen.parse-failure? W662) (shen.parse-failure) W662)) W659)) W652)) W638)))

(defun shen.<constructor> (V666) (let W667 (if (cons? V666) (let W668 (head V666) (let W669 (tail V666) (if (shen.constructor? W668) (shen.comb W669 W668) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W667) (shen.parse-failure) W667)))

(defun shen.constructor? (V670) (element? V670 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V671) (simple-error (shen.app V671 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V672) (let W673 (if (cons? V672) (let W674 (head V672) (let W675 (tail V672) (if (= W674 _) (shen.comb W675 (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W673) (let W676 (if (cons? V672) (let W677 (head V672) (let W678 (tail V672) (if (not (element? W677 (cons -> (cons <- ())))) (shen.comb W678 W677) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W676) (shen.parse-failure) W676)) W673)))

(defun shen.<pattern1> (V679) (let W680 (let W681 (shen.<pattern> V679) (if (shen.parse-failure? W681) (shen.parse-failure) (let W682 (shen.<-out W681) (let W683 (shen.in-> W681) (shen.comb W683 W682))))) (if (shen.parse-failure? W680) (shen.parse-failure) W680)))

(defun shen.<pattern2> (V684) (let W685 (let W686 (shen.<pattern> V684) (if (shen.parse-failure? W686) (shen.parse-failure) (let W687 (shen.<-out W686) (let W688 (shen.in-> W686) (shen.comb W688 W687))))) (if (shen.parse-failure? W685) (shen.parse-failure) W685)))

(defun shen.fn-print (V689) (let W690 (absvector 2) (let W691 (address-> W690 0 shen.printF) (let W692 (address-> W691 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V689) ")")))))) W692))))

(defun shen.printF (V693) (<-address V693 1))

(defun shen.arity-chk (V698 V699) (cond ((and (cons? V699) (= () (tl V699))) (length (hd V699))) ((and (cons? V699) (and (cons? (tl V699)) (= (length (hd V699)) (length (hd (tl V699)))))) (shen.arity-chk V698 (tl V699))) (true (simple-error (cn "arity error in " (shen.app V698 "
" shen.a))))))

(defun shen.free-var-chk (V700 V701) (cond ((tuple? V701) (shen.free-variable-error-message V700 (shen.find-free-vars (shen.extract-vars (fst V701)) (snd V701)))) (true (shen.f-error shen.free-var-chk))))

(defun shen.free-variable-error-message (V702 V703) (if (empty? V703) shen.skip (do (pr (cn "free variables in " (shen.app V702 ":" shen.a)) (stoutput)) (do (shen.for-each (lambda Z704 (pr (cn " " (shen.app Z704 "" shen.a)) (stoutput))) V703) (do (nl 1) (abort))))))

(defun shen.extract-vars (V707) (cond ((variable? V707) (cons V707 ())) ((cons? V707) (union (shen.extract-vars (hd V707)) (shen.extract-vars (tl V707)))) (true ())))

(defun shen.find-free-vars (V712 V713) (cond ((and (cons? V713) (and (= protect (hd V713)) (and (cons? (tl V713)) (= () (tl (tl V713)))))) ()) ((and (cons? V713) (and (= let (hd V713)) (and (cons? (tl V713)) (and (cons? (tl (tl V713))) (and (cons? (tl (tl (tl V713)))) (= () (tl (tl (tl (tl V713)))))))))) (union (shen.find-free-vars V712 (hd (tl (tl V713)))) (shen.find-free-vars (cons (hd (tl V713)) V712) (hd (tl (tl (tl V713))))))) ((and (cons? V713) (and (= lambda (hd V713)) (and (cons? (tl V713)) (and (cons? (tl (tl V713))) (= () (tl (tl (tl V713)))))))) (shen.find-free-vars (cons (hd (tl V713)) V712) (hd (tl (tl V713))))) ((cons? V713) (union (shen.find-free-vars V712 (hd V713)) (shen.find-free-vars V712 (tl V713)))) ((shen.free-variable? V713 V712) (cons V713 ())) (true ())))

(defun shen.free-variable? (V714 V715) (and (variable? V714) (not (element? V714 V715))))

(defun shen.record-kl (V716 V717) (put V716 shen.source V717 (value *property-vector*)))

(defun shen.compile-to-kl (V718 V719 V720) (let W721 (shen.parameters V720) (let W722 (shen.scan-body V718 (shen.kl-body V719 W721)) (let W723 (cons defun (cons V718 (cons W721 (cons (shen.cond-form W722) ())))) W723))))

(defun shen.parameters (V724) (cond ((= 0 V724) ()) (true (cons (gensym V) (shen.parameters (- V724 1))))))

(defun shen.cond-form (V727) (cond ((and (cons? V727) (and (cons? (hd V727)) (and (= true (hd (hd V727))) (and (cons? (tl (hd V727))) (= () (tl (tl (hd V727)))))))) (hd (tl (hd V727)))) (true (cons cond V727))))

(defun shen.scan-body (V736 V737) (cond ((= () V737) (cons (cons true (cons (cons shen.f-error (cons V736 ())) ())) ())) ((and (cons? V737) (shen.choicepoint? (hd V737))) (shen.choicepoint V736 (gensym Freeze) (gensym Result) (hd V737) (tl V737))) ((and (cons? V737) (and (cons? (hd V737)) (and (= true (hd (hd V737))) (and (cons? (tl (hd V737))) (= () (tl (tl (hd V737)))))))) (cons (hd V737) ())) ((cons? V737) (cons (hd V737) (shen.scan-body V736 (tl V737)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V744) (cond ((and (cons? V744) (and (cons? (tl V744)) (and (cons? (hd (tl V744))) (and (= shen.choicepoint! (hd (hd (tl V744)))) (and (cons? (tl (hd (tl V744)))) (and (= () (tl (tl (hd (tl V744))))) (= () (tl (tl V744))))))))) true) (true false)))

(defun shen.choicepoint (V760 V761 V762 V763 V764) (cond ((and (cons? V763) (and (cons? (tl V763)) (and (cons? (hd (tl V763))) (and (cons? (tl (hd (tl V763)))) (and (cons? (hd (tl (hd (tl V763))))) (and (= fail-if (hd (hd (tl (hd (tl V763)))))) (and (cons? (tl (hd (tl (hd (tl V763)))))) (and (cons? (tl (tl (hd (tl (hd (tl V763))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V763)))))))) (and (= () (tl (tl (hd (tl V763))))) (and (= () (tl (tl V763))) (= V760 (hd (tl (hd (tl (hd (tl V763)))))))))))))))))) (cons (cons true (cons (cons let (cons V761 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V763)))))) V764)) ())) (cons (cons if (cons (hd V763) (cons (cons let (cons V762 (cons (hd (tl (tl (hd (tl (hd (tl V763))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V763)))))) (cons V762 ())) (cons (cons thaw (cons V761 ())) (cons V762 ())))) ())))) (cons (cons thaw (cons V761 ())) ())))) ())))) ())) ())) ((and (cons? V763) (and (cons? (tl V763)) (and (cons? (hd (tl V763))) (and (cons? (tl (hd (tl V763)))) (and (= () (tl (tl (hd (tl V763))))) (= () (tl (tl V763)))))))) (cons (cons true (cons (cons let (cons V761 (cons (cons freeze (cons (cons cond (shen.scan-body V760 V764)) ())) (cons (cons if (cons (hd V763) (cons (cons let (cons V762 (cons (hd (tl (hd (tl V763)))) (cons (cons if (cons (cons = (cons V762 (cons (cons fail ()) ()))) (cons (cons thaw (cons V761 ())) (cons V762 ())))) ())))) (cons (cons thaw (cons V761 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V766 V767 V768) (cond ((= V766 V768) V767) ((cons? V768) (let W769 (shen.rep-X V766 V767 (hd V768)) (if (= W769 (hd V768)) (cons (hd V768) (shen.rep-X V766 V767 (tl V768))) (cons W769 (tl V768))))) (true V768)))

(defun shen.alpha-convert (V770) (cond ((and (cons? V770) (and (= lambda (hd V770)) (and (cons? (tl V770)) (and (cons? (tl (tl V770))) (= () (tl (tl (tl V770)))))))) (let W771 (gensym Z) (let W772 (cons lambda (cons W771 (cons (shen.beta (hd (tl V770)) W771 (hd (tl (tl V770)))) ()))) (map (lambda Z773 (shen.alpha-convert Z773)) W772)))) ((and (cons? V770) (and (= let (hd V770)) (and (cons? (tl V770)) (and (cons? (tl (tl V770))) (and (cons? (tl (tl (tl V770)))) (= () (tl (tl (tl (tl V770)))))))))) (let W774 (gensym W) (let W775 (cons let (cons W774 (cons (hd (tl (tl V770))) (cons (shen.beta (hd (tl V770)) W774 (hd (tl (tl (tl V770))))) ())))) (map (lambda Z776 (shen.alpha-convert Z776)) W775)))) ((cons? V770) (map (lambda Z777 (shen.alpha-convert Z777)) V770)) (true V770)))

(defun shen.kl-body (V778 V779) (map (lambda Z780 (shen.triple-stack () (fst Z780) V779 (shen.alpha-convert (snd Z780)))) V778))

(defun shen.triple-stack (V789 V790 V791 V792) (cond ((and (= () V790) (and (= () V791) (and (cons? V792) (and (= where (hd V792)) (and (cons? (tl V792)) (and (cons? (tl (tl V792))) (= () (tl (tl (tl V792)))))))))) (shen.triple-stack (cons (hd (tl V792)) V789) () () (hd (tl (tl V792))))) ((and (= () V790) (= () V791)) (cons (shen.rectify-test (reverse V789)) (cons V792 ()))) ((and (cons? V790) (and (cons? V791) (variable? (hd V790)))) (shen.triple-stack V789 (tl V790) (tl V791) (shen.beta (hd V790) (hd V791) V792))) ((and (cons? V790) (and (cons? (hd V790)) (and (cons? (tl (hd V790))) (and (cons? (tl (tl (hd V790)))) (and (= () (tl (tl (tl (hd V790))))) (cons? V791)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V790))) (cons (hd V791) ())) V789) (cons (hd (tl (hd V790))) (cons (hd (tl (tl (hd V790)))) (tl V790))) (cons (cons (shen.op1 (hd (hd V790))) (cons (hd V791) ())) (cons (cons (shen.op2 (hd (hd V790))) (cons (hd V791) ())) (tl V791))) (shen.beta (hd V790) (hd V791) V792))) ((and (cons? V790) (cons? V791)) (shen.triple-stack (cons (cons = (cons (hd V790) (cons (hd V791) ()))) V789) (tl V790) (tl V791) V792)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V795) (cond ((= () V795) true) ((and (cons? V795) (= () (tl V795))) (hd V795)) ((and (cons? V795) (cons? (tl V795))) (cons and (cons (hd V795) (cons (shen.rectify-test (tl V795)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V805 V806 V807) (cond ((= V805 V807) V806) ((and (cons? V807) (and (= lambda (hd V807)) (and (cons? (tl V807)) (and (cons? (tl (tl V807))) (and (= () (tl (tl (tl V807)))) (= V805 (hd (tl V807)))))))) V807) ((and (cons? V807) (and (= let (hd V807)) (and (cons? (tl V807)) (and (cons? (tl (tl V807))) (and (cons? (tl (tl (tl V807)))) (and (= () (tl (tl (tl (tl V807))))) (= V805 (hd (tl V807))))))))) (cons let (cons (hd (tl V807)) (cons (shen.beta (hd (tl V807)) V806 (hd (tl (tl V807)))) (tl (tl (tl V807))))))) ((cons? V807) (map (lambda Z808 (shen.beta V805 V806 Z808)) V807)) (true V807)))

(defun shen.op1 (V811) (cond ((= cons V811) hd) ((= @s V811) hdstr) ((= @p V811) fst) ((= @v V811) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V814) (cond ((= cons V814) tl) ((= @s V814) tlstr) ((= @p V814) snd) ((= @v V814) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V817) (cond ((= cons V817) cons?) ((= @s V817) shen.+string?) ((= @p V817) tuple?) ((= @v V817) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V818) (cond ((= "" V818) false) (true (string? V818))))

(defun shen.+vector? (V819) (cond ((= V819 (vector 0)) false) (true (vector? V819))))

(defun factorise (V822) (cond ((= + V822) (set shen.*factorise?* true)) ((= - V822) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V823) (cond ((value shen.*factorise?*) (shen.factor V823)) (true V823)))

(defun shen.factor (V824) (cond ((and (cons? V824) (and (= defun (hd V824)) (and (cons? (tl V824)) (and (cons? (tl (tl V824))) (and (cons? (tl (tl (tl V824)))) (and (cons? (hd (tl (tl (tl V824))))) (and (= cond (hd (hd (tl (tl (tl V824)))))) (= () (tl (tl (tl (tl V824)))))))))))) (cons defun (cons (hd (tl V824)) (cons (hd (tl (tl V824))) (cons (shen.factor-recognisors (tl (hd (tl (tl (tl V824)))))) ()))))) (true V824)))

(defun shen.factor-recognisors (V827) (cond ((and (cons? V827) (and (cons? (hd V827)) (and (= true (hd (hd V827))) (and (cons? (tl (hd V827))) (= () (tl (tl (hd V827)))))))) (hd (tl (hd V827)))) ((and (cons? V827) (and (cons? (hd V827)) (and (cons? (hd (hd V827))) (and (= and (hd (hd (hd V827)))) (and (cons? (tl (hd (hd V827)))) (and (cons? (tl (tl (hd (hd V827))))) (and (= () (tl (tl (tl (hd (hd V827)))))) (and (cons? (tl (hd V827))) (= () (tl (tl (hd V827)))))))))))) (let W828 (shen.pivot-on (hd (tl (hd (hd V827)))) V827 ()) (let W829 (fst W828) (if (shen.bad-pivot? W829) (cons if (cons (hd (hd V827)) (cons (hd (tl (hd V827))) (cons (shen.factor-recognisors (tl V827)) ())))) (let W830 (snd W828) (let W831 (shen.factor-recognisors W830) (let W832 (gensym GoTo) (let W833 (reverse (cons (cons true (cons (cons thaw (cons W832 ())) ())) W829)) (let W834 (cons let (cons W832 (cons (cons freeze (cons W831 ())) (cons (cons if (cons (hd (tl (hd (hd V827)))) (cons (shen.factor-selectors (hd (tl (hd (hd V827)))) (shen.factor-recognisors W833)) (cons (cons thaw (cons W832 ())) ())))) ())))) (shen.remove-indirection W834)))))))))) ((and (cons? V827) (and (cons? (hd V827)) (and (cons? (tl (hd V827))) (= () (tl (tl (hd V827))))))) (cons if (cons (hd (hd V827)) (cons (hd (tl (hd V827))) (cons (shen.factor-recognisors (tl V827)) ()))))) (true (shen.f-error shen.factor-recognisors))))

(defun shen.bad-pivot? (V839) (cond ((and (cons? V839) (= () (tl V839))) true) (true false)))

(defun shen.remove-indirection (V840) (cond ((and (cons? V840) (and (= let (hd V840)) (and (cons? (tl V840)) (and (cons? (tl (tl V840))) (and (cons? (hd (tl (tl V840)))) (and (= freeze (hd (hd (tl (tl V840))))) (and (cons? (tl (hd (tl (tl V840))))) (and (cons? (hd (tl (hd (tl (tl V840)))))) (and (= thaw (hd (hd (tl (hd (tl (tl V840))))))) (and (cons? (tl (hd (tl (hd (tl (tl V840))))))) (and (= () (tl (tl (hd (tl (hd (tl (tl V840)))))))) (and (= () (tl (tl (hd (tl (tl V840)))))) (and (cons? (tl (tl (tl V840)))) (and (= () (tl (tl (tl (tl V840))))) (symbol? (hd (tl (hd (tl (hd (tl (tl V840)))))))))))))))))))))) (subst (hd (tl (hd (tl (hd (tl (tl V840))))))) (hd (tl V840)) (hd (tl (tl (tl V840)))))) (true V840)))

(defun shen.pivot-on (V843 V844 V845) (cond ((and (cons? V844) (and (cons? (hd V844)) (and (cons? (hd (hd V844))) (and (= and (hd (hd (hd V844)))) (and (cons? (tl (hd (hd V844)))) (and (cons? (tl (tl (hd (hd V844))))) (and (= () (tl (tl (tl (hd (hd V844)))))) (and (cons? (tl (hd V844))) (and (= () (tl (tl (hd V844)))) (= V843 (hd (tl (hd (hd V844)))))))))))))) (shen.pivot-on (hd (tl (hd (hd V844)))) (tl V844) (cons (cons (hd (tl (tl (hd (hd V844))))) (tl (hd V844))) V845))) ((and (cons? V844) (and (cons? (hd V844)) (and (cons? (tl (hd V844))) (and (= () (tl (tl (hd V844)))) (= V843 (hd (hd V844))))))) (shen.pivot-on (hd (hd V844)) (tl V844) (cons (cons true (tl (hd V844))) V845))) (true (@p V845 V844))))

(defun shen.factor-selectors (V848 V849) (cond ((and (cons? V848) (and (cons? (tl V848)) (= () (tl (tl V848))))) (let W850 (shen.op (hd V848)) (if (= shen.skip W850) V849 (shen.factor-selectors-h (cons (cons (shen.op1 W850) (tl V848)) (cons (cons (shen.op2 W850) (tl V848)) ())) V849)))) (true V849)))

(defun shen.op (V853) (cond ((= cons? V853) cons) ((= shen.+string? V853) @s) ((= shen.+vector? V853) @v) ((= tuple? V853) @p) (true shen.skip)))

(defun shen.factor-selectors-h (V854 V855) (cond ((= () V854) V855) ((cons? V854) (if (> (occurrences (hd V854) V855) 1) (let W856 (gensym Select) (cons let (cons W856 (cons (hd V854) (cons (shen.factor-selectors-h (tl V854) (subst W856 (hd V854) V855)) ()))))) (shen.factor-selectors-h (tl V854) V855))) (true (shen.f-error shen.factor-selectors-h))))

