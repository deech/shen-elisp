(defun read-file (V2481) (let W2482 (read-file-as-bytelist V2481) (let W2483 (trap-error (compile (lambda Z2484 (shen.<s-exprs> Z2484)) W2482) (lambda Z2485 (shen.print-residue (value shen.*residue*)))) (let W2486 (shen.process-sexprs W2483) W2486))))

(defun shen.print-residue (V2487) (let W2488 (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V2487)))

(defun shen.nchars (V2493 V2494) (cond ((= 0 V2493) (do (pr " ..." (stoutput)) (abort))) ((= () V2494) (do (pr " ..." (stoutput)) (abort))) ((cons? V2494) (do (pr (n->string (hd V2494)) (stoutput)) (shen.nchars (- V2493 1) (tl V2494)))) (true (shen.f-error shen.nchars))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V2495) (let W2496 (open V2495 in) (let W2497 (read-byte W2496) (let W2498 (shen.read-file-as-bytelist-help W2496 W2497 ()) (let W2499 (close W2496) (reverse W2498))))))

(defun shen.read-file-as-bytelist-help (V2500 V2501 V2502) (cond ((= -1 V2501) V2502) (true (shen.read-file-as-bytelist-help V2500 (read-byte V2500) (cons V2501 V2502)))))

(defun read-file-as-string (V2503) (let W2504 (open V2503 in) (shen.rfas-h W2504 (read-byte W2504) "")))

(defun shen.rfas-h (V2505 V2506 V2507) (cond ((= -1 V2506) (do (close V2505) V2507)) (true (shen.rfas-h V2505 (read-byte V2505) (cn V2507 (n->string V2506))))))

(defun input (V2508) (eval-kl (read V2508)))

(defun input+ (V2509 V2510) (let W2511 (shen.monotype V2509) (let W2512 (read V2510) (if (= false (shen.typecheck W2512 (shen.rectify-type V2509))) (simple-error (cn "type error: " (shen.app W2512 (cn " is not of type " (shen.app V2509 "
" shen.r)) shen.r))) (eval-kl W2512)))))

(defun shen.monotype (V2513) (cond ((cons? V2513) (map (lambda Z2514 (shen.monotype Z2514)) V2513)) (true (if (variable? V2513) (simple-error (cn "input+ expects a monotype: not " (shen.app V2513 "
" shen.a))) V2513))))

(defun lineread (V2515) (shen.read-loop V2515 (shen.my-read-byte V2515) () (lambda Z2516 (shen.return? Z2516))))

(defun read-from-string (V2517) (let W2518 (shen.str->bytes V2517) (let W2519 (compile (lambda Z2520 (shen.<s-exprs> Z2520)) W2518) (let W2521 (shen.process-sexprs W2519) W2521))))

(defun read-from-string-unprocessed (V2522) (let W2523 (shen.str->bytes V2522) (let W2524 (compile (lambda Z2525 (shen.<s-exprs> Z2525)) W2523) W2524)))

(defun shen.str->bytes (V2526) (cond ((= "" V2526) ()) ((shen.+string? V2526) (cons (string->n (hdstr V2526)) (shen.str->bytes (tlstr V2526)))) (true (shen.f-error shen.str->bytes))))

(defun read (V2527) (hd (shen.read-loop V2527 (shen.my-read-byte V2527) () (lambda Z2528 (shen.whitespace? Z2528)))))

(defun shen.my-read-byte (V2529) (if (shen.char-stinput? V2529) (string->n (shen.read-unit-string V2529)) (read-byte V2529)))

(defun shen.read-loop (V2534 V2535 V2536 V2537) (cond ((= 94 V2535) (simple-error "read aborted")) ((= -1 V2535) (if (empty? V2536) (simple-error "error: empty stream") (compile (lambda Z2538 (shen.<s-exprs> Z2538)) V2536))) ((= 0 V2535) (shen.read-loop V2534 (shen.my-read-byte V2534) V2536 V2537)) (true (if (V2537 V2535) (let W2539 (shen.try-parse V2536) (if (shen.nothing-doing? W2539) (shen.read-loop V2534 (shen.my-read-byte V2534) (append V2536 (cons V2535 ())) V2537) (do (shen.record-it V2536) W2539))) (shen.read-loop V2534 (shen.my-read-byte V2534) (append V2536 (cons V2535 ())) V2537)))))

(defun shen.try-parse (V2540) (let W2541 (trap-error (compile (lambda Z2542 (shen.<s-exprs> Z2542)) V2540) (lambda Z2543 shen.i-failed!)) (if (shen.nothing-doing? W2541) shen.i-failed! (shen.process-sexprs W2541))))

(defun shen.nothing-doing? (V2546) (cond ((= shen.i-failed! V2546) true) ((= () V2546) true) (true false)))

(defun shen.record-it (V2547) (set shen.*it* (shen.bytes->string V2547)))

(defun shen.bytes->string (V2548) (cond ((= () V2548) "") ((cons? V2548) (cn (n->string (hd V2548)) (shen.bytes->string (tl V2548)))) (true (shen.f-error shen.bytes->string))))

(defun shen.process-sexprs (V2549) (let W2550 (shen.unpackage&macroexpand V2549) (let W2551 (shen.find-arities W2550) (let W2552 (shen.find-types W2550) (map (lambda Z2553 (shen.process-applications Z2553 W2552)) W2550)))))

(defun shen.find-types (V2554) (cond ((and (cons? V2554) (and (cons? (tl V2554)) (= (hd V2554) (intern ":")))) (cons (hd (tl V2554)) (shen.find-types (tl (tl V2554))))) ((cons? V2554) (append (shen.find-types (hd V2554)) (shen.find-types (tl V2554)))) (true ())))

(defun shen.find-arities (V2557) (cond ((and (cons? V2557) (and (= define (hd V2557)) (and (cons? (tl V2557)) (and (cons? (tl (tl V2557))) (= { (hd (tl (tl V2557)))))))) (shen.store-arity (hd (tl V2557)) (shen.find-arity (hd (tl V2557)) 1 (tl (tl (tl V2557)))))) ((and (cons? V2557) (and (= define (hd V2557)) (cons? (tl V2557)))) (shen.store-arity (hd (tl V2557)) (shen.find-arity (hd (tl V2557)) 0 (tl (tl V2557))))) ((cons? V2557) (map (lambda Z2558 (shen.find-arities Z2558)) V2557)) (true shen.skip)))

(defun shen.store-arity (V2559 V2560) (let W2561 (arity V2559) (if (= W2561 -1) (shen.execute-store-arity V2559 V2560) (if (= W2561 V2560) shen.skip (if (shen.sysfunc? V2559) (simple-error (shen.app V2559 " is a system function
" shen.a)) (do (pr (cn "changing the arity of " (shen.app V2559 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V2559 V2560)))))))

(defun shen.execute-store-arity (V2562 V2563) (cond ((= 0 V2563) (put V2562 arity 0 (value *property-vector*))) (true (do (put V2562 arity V2563 (value *property-vector*)) (shen.update-lambdatable V2562 V2563)))))

(defun shen.update-lambdatable (V2564 V2565) (let W2566 (eval-kl (shen.lambda-function (cons V2564 ()) V2565)) (let W2567 (shen.set-lambda-form-entry (cons V2564 W2566)) V2565)))

(defun shen.lambda-function (V2570 V2571) (cond ((= 0 V2571) shen.skip) ((= 1 V2571) (let W2572 (gensym Y) (cons lambda (cons W2572 (cons (append V2570 (cons W2572 ())) ()))))) (true (let W2573 (gensym Y) (cons lambda (cons W2573 (cons (shen.lambda-function (append V2570 (cons W2573 ())) (- V2571 1)) ())))))))

(defun shen.assoc-> (V2583 V2584 V2585) (cond ((= () V2585) (cons (cons V2583 V2584) ())) ((and (cons? V2585) (and (cons? (hd V2585)) (= V2583 (hd (hd V2585))))) (cons (cons (hd (hd V2585)) V2584) (tl V2585))) ((cons? V2585) (cons (hd V2585) (shen.assoc-> V2583 V2584 (tl V2585)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V2600 V2601 V2602) (cond ((and (= 0 V2601) (and (cons? V2602) (= (hd V2602) ->))) 0) ((and (= 0 V2601) (and (cons? V2602) (= (hd V2602) <-))) 0) ((and (= 0 V2601) (cons? V2602)) (+ 1 (shen.find-arity V2600 0 (tl V2602)))) ((and (= 1 V2601) (and (cons? V2602) (= } (hd V2602)))) (shen.find-arity V2600 0 (tl V2602))) ((and (= 1 V2601) (cons? V2602)) (shen.find-arity V2600 1 (tl V2602))) ((= 1 V2601) (simple-error (cn "syntax error in " (shen.app V2600 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V2600 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V2603) (let W2604 (let W2605 (shen.<lsb> V2603) (if (shen.parse-failure? W2605) (shen.parse-failure) (let W2606 (shen.in-> W2605) (let W2607 (shen.<s-exprs1> W2606) (if (shen.parse-failure? W2607) (shen.parse-failure) (let W2608 (shen.<-out W2607) (let W2609 (shen.in-> W2607) (let W2610 (shen.<rsb> W2609) (if (shen.parse-failure? W2610) (shen.parse-failure) (let W2611 (shen.in-> W2610) (let W2612 (shen.<s-exprs2> W2611) (if (shen.parse-failure? W2612) (shen.parse-failure) (let W2613 (shen.<-out W2612) (let W2614 (shen.in-> W2612) (shen.comb W2614 (cons (shen.cons-form W2608) W2613)))))))))))))))) (if (shen.parse-failure? W2604) (let W2615 (let W2616 (shen.<lrb> V2603) (if (shen.parse-failure? W2616) (shen.parse-failure) (let W2617 (shen.in-> W2616) (let W2618 (shen.<s-exprs1> W2617) (if (shen.parse-failure? W2618) (shen.parse-failure) (let W2619 (shen.<-out W2618) (let W2620 (shen.in-> W2618) (let W2621 (shen.<rrb> W2620) (if (shen.parse-failure? W2621) (shen.parse-failure) (let W2622 (shen.in-> W2621) (let W2623 (shen.<s-exprs2> W2622) (if (shen.parse-failure? W2623) (shen.parse-failure) (let W2624 (shen.<-out W2623) (let W2625 (shen.in-> W2623) (shen.comb W2625 (shen.add-sexpr W2619 W2624)))))))))))))))) (if (shen.parse-failure? W2615) (let W2626 (let W2627 (shen.<lcurly> V2603) (if (shen.parse-failure? W2627) (shen.parse-failure) (let W2628 (shen.in-> W2627) (let W2629 (shen.<s-exprs> W2628) (if (shen.parse-failure? W2629) (shen.parse-failure) (let W2630 (shen.<-out W2629) (let W2631 (shen.in-> W2629) (shen.comb W2631 (cons { W2630))))))))) (if (shen.parse-failure? W2626) (let W2632 (let W2633 (shen.<rcurly> V2603) (if (shen.parse-failure? W2633) (shen.parse-failure) (let W2634 (shen.in-> W2633) (let W2635 (shen.<s-exprs> W2634) (if (shen.parse-failure? W2635) (shen.parse-failure) (let W2636 (shen.<-out W2635) (let W2637 (shen.in-> W2635) (shen.comb W2637 (cons } W2636))))))))) (if (shen.parse-failure? W2632) (let W2638 (let W2639 (shen.<bar> V2603) (if (shen.parse-failure? W2639) (shen.parse-failure) (let W2640 (shen.in-> W2639) (let W2641 (shen.<s-exprs> W2640) (if (shen.parse-failure? W2641) (shen.parse-failure) (let W2642 (shen.<-out W2641) (let W2643 (shen.in-> W2641) (shen.comb W2643 (cons bar! W2642))))))))) (if (shen.parse-failure? W2638) (let W2644 (let W2645 (shen.<semicolon> V2603) (if (shen.parse-failure? W2645) (shen.parse-failure) (let W2646 (shen.in-> W2645) (let W2647 (shen.<s-exprs> W2646) (if (shen.parse-failure? W2647) (shen.parse-failure) (let W2648 (shen.<-out W2647) (let W2649 (shen.in-> W2647) (shen.comb W2649 (cons (intern ";") W2648))))))))) (if (shen.parse-failure? W2644) (let W2650 (let W2651 (shen.<colon> V2603) (if (shen.parse-failure? W2651) (shen.parse-failure) (let W2652 (shen.in-> W2651) (let W2653 (shen.<equal> W2652) (if (shen.parse-failure? W2653) (shen.parse-failure) (let W2654 (shen.in-> W2653) (let W2655 (shen.<s-exprs> W2654) (if (shen.parse-failure? W2655) (shen.parse-failure) (let W2656 (shen.<-out W2655) (let W2657 (shen.in-> W2655) (shen.comb W2657 (cons (intern ":=") W2656)))))))))))) (if (shen.parse-failure? W2650) (let W2658 (let W2659 (shen.<colon> V2603) (if (shen.parse-failure? W2659) (shen.parse-failure) (let W2660 (shen.in-> W2659) (let W2661 (shen.<s-exprs> W2660) (if (shen.parse-failure? W2661) (shen.parse-failure) (let W2662 (shen.<-out W2661) (let W2663 (shen.in-> W2661) (shen.comb W2663 (cons (intern ":") W2662))))))))) (if (shen.parse-failure? W2658) (let W2664 (let W2665 (shen.<comma> V2603) (if (shen.parse-failure? W2665) (shen.parse-failure) (let W2666 (shen.in-> W2665) (let W2667 (shen.<s-exprs> W2666) (if (shen.parse-failure? W2667) (shen.parse-failure) (let W2668 (shen.<-out W2667) (let W2669 (shen.in-> W2667) (shen.comb W2669 (cons (intern ",") W2668))))))))) (if (shen.parse-failure? W2664) (let W2670 (let W2671 (shen.<comment> V2603) (if (shen.parse-failure? W2671) (shen.parse-failure) (let W2672 (shen.in-> W2671) (let W2673 (shen.<s-exprs> W2672) (if (shen.parse-failure? W2673) (shen.parse-failure) (let W2674 (shen.<-out W2673) (let W2675 (shen.in-> W2673) (shen.comb W2675 W2674)))))))) (if (shen.parse-failure? W2670) (let W2676 (let W2677 (shen.<atom> V2603) (if (shen.parse-failure? W2677) (shen.parse-failure) (let W2678 (shen.<-out W2677) (let W2679 (shen.in-> W2677) (let W2680 (shen.<s-exprs> W2679) (if (shen.parse-failure? W2680) (shen.parse-failure) (let W2681 (shen.<-out W2680) (let W2682 (shen.in-> W2680) (shen.comb W2682 (cons W2678 W2681)))))))))) (if (shen.parse-failure? W2676) (let W2683 (let W2684 (shen.<whitespaces> V2603) (if (shen.parse-failure? W2684) (shen.parse-failure) (let W2685 (shen.in-> W2684) (let W2686 (shen.<s-exprs> W2685) (if (shen.parse-failure? W2686) (shen.parse-failure) (let W2687 (shen.<-out W2686) (let W2688 (shen.in-> W2686) (shen.comb W2688 W2687)))))))) (if (shen.parse-failure? W2683) (let W2689 (let W2690 (<e> V2603) (if (shen.parse-failure? W2690) (shen.parse-failure) (let W2691 (shen.in-> W2690) (shen.comb W2691 ())))) (if (shen.parse-failure? W2689) (shen.parse-failure) W2689)) W2683)) W2676)) W2670)) W2664)) W2658)) W2650)) W2644)) W2638)) W2632)) W2626)) W2615)) W2604)))

(defun shen.add-sexpr (V2692 V2693) (cond ((and (cons? V2692) (and (= $ (hd V2692)) (and (cons? (tl V2692)) (= () (tl (tl V2692)))))) (append (explode (hd (tl V2692))) V2693)) (true (cons V2692 V2693))))

(defun shen.<lsb> (V2694) (let W2695 (if (shen.hds=? V2694 91) (let W2696 (tail V2694) (shen.comb W2696 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2695) (shen.parse-failure) W2695)))

(defun shen.<rsb> (V2697) (let W2698 (if (shen.hds=? V2697 93) (let W2699 (tail V2697) (shen.comb W2699 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2698) (shen.parse-failure) W2698)))

(defun shen.<s-exprs1> (V2700) (let W2701 (let W2702 (shen.<s-exprs> V2700) (if (shen.parse-failure? W2702) (shen.parse-failure) (let W2703 (shen.<-out W2702) (let W2704 (shen.in-> W2702) (shen.comb W2704 W2703))))) (if (shen.parse-failure? W2701) (shen.parse-failure) W2701)))

(defun shen.<s-exprs2> (V2705) (let W2706 (let W2707 (shen.<s-exprs> V2705) (if (shen.parse-failure? W2707) (shen.parse-failure) (let W2708 (shen.<-out W2707) (let W2709 (shen.in-> W2707) (shen.comb W2709 W2708))))) (if (shen.parse-failure? W2706) (shen.parse-failure) W2706)))

(defun shen.cons-form (V2711) (cond ((= () V2711) ()) ((and (cons? V2711) (and (cons? (tl V2711)) (and (cons? (tl (tl V2711))) (and (= () (tl (tl (tl V2711)))) (= (hd (tl V2711)) bar!))))) (cons cons (cons (hd V2711) (tl (tl V2711))))) ((and (cons? V2711) (and (cons? (tl V2711)) (and (cons? (tl (tl V2711))) (and (cons? (tl (tl (tl V2711)))) (= (hd (tl V2711)) bar!))))) (simple-error "misapplication of |
")) ((cons? V2711) (cons cons (cons (hd V2711) (cons (shen.cons-form (tl V2711)) ())))) (true (shen.f-error shen.cons-form))))

(defun shen.<lrb> (V2712) (let W2713 (if (shen.hds=? V2712 40) (let W2714 (tail V2712) (shen.comb W2714 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2713) (shen.parse-failure) W2713)))

(defun shen.<rrb> (V2715) (let W2716 (if (shen.hds=? V2715 41) (let W2717 (tail V2715) (shen.comb W2717 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2716) (shen.parse-failure) W2716)))

(defun shen.<lcurly> (V2718) (let W2719 (if (shen.hds=? V2718 123) (let W2720 (tail V2718) (shen.comb W2720 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2719) (shen.parse-failure) W2719)))

(defun shen.<rcurly> (V2721) (let W2722 (if (shen.hds=? V2721 125) (let W2723 (tail V2721) (shen.comb W2723 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2722) (shen.parse-failure) W2722)))

(defun shen.<bar> (V2724) (let W2725 (if (shen.hds=? V2724 124) (let W2726 (tail V2724) (shen.comb W2726 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2725) (shen.parse-failure) W2725)))

(defun shen.<semicolon> (V2727) (let W2728 (if (shen.hds=? V2727 59) (let W2729 (tail V2727) (shen.comb W2729 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2728) (shen.parse-failure) W2728)))

(defun shen.<colon> (V2730) (let W2731 (if (shen.hds=? V2730 58) (let W2732 (tail V2730) (shen.comb W2732 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2731) (shen.parse-failure) W2731)))

(defun shen.<comma> (V2733) (let W2734 (if (shen.hds=? V2733 44) (let W2735 (tail V2733) (shen.comb W2735 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2734) (shen.parse-failure) W2734)))

(defun shen.<equal> (V2736) (let W2737 (if (shen.hds=? V2736 61) (let W2738 (tail V2736) (shen.comb W2738 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2737) (shen.parse-failure) W2737)))

(defun shen.<comment> (V2739) (let W2740 (let W2741 (shen.<singleline> V2739) (if (shen.parse-failure? W2741) (shen.parse-failure) (let W2742 (shen.in-> W2741) (shen.comb W2742 shen.skip)))) (if (shen.parse-failure? W2740) (let W2743 (let W2744 (shen.<multiline> V2739) (if (shen.parse-failure? W2744) (shen.parse-failure) (let W2745 (shen.in-> W2744) (shen.comb W2745 shen.skip)))) (if (shen.parse-failure? W2743) (shen.parse-failure) W2743)) W2740)))

(defun shen.<singleline> (V2746) (let W2747 (let W2748 (shen.<backslash> V2746) (if (shen.parse-failure? W2748) (shen.parse-failure) (let W2749 (shen.in-> W2748) (let W2750 (shen.<backslash> W2749) (if (shen.parse-failure? W2750) (shen.parse-failure) (let W2751 (shen.in-> W2750) (let W2752 (shen.<shortnatters> W2751) (if (shen.parse-failure? W2752) (shen.parse-failure) (let W2753 (shen.in-> W2752) (let W2754 (shen.<returns> W2753) (if (shen.parse-failure? W2754) (shen.parse-failure) (let W2755 (shen.in-> W2754) (shen.comb W2755 shen.skip))))))))))))) (if (shen.parse-failure? W2747) (shen.parse-failure) W2747)))

(defun shen.<backslash> (V2756) (let W2757 (if (shen.hds=? V2756 92) (let W2758 (tail V2756) (shen.comb W2758 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2757) (shen.parse-failure) W2757)))

(defun shen.<shortnatters> (V2759) (let W2760 (let W2761 (shen.<shortnatter> V2759) (if (shen.parse-failure? W2761) (shen.parse-failure) (let W2762 (shen.in-> W2761) (let W2763 (shen.<shortnatters> W2762) (if (shen.parse-failure? W2763) (shen.parse-failure) (let W2764 (shen.in-> W2763) (shen.comb W2764 shen.skip))))))) (if (shen.parse-failure? W2760) (let W2765 (let W2766 (<e> V2759) (if (shen.parse-failure? W2766) (shen.parse-failure) (let W2767 (shen.in-> W2766) (shen.comb W2767 shen.skip)))) (if (shen.parse-failure? W2765) (shen.parse-failure) W2765)) W2760)))

(defun shen.<shortnatter> (V2768) (let W2769 (if (cons? V2768) (let W2770 (head V2768) (let W2771 (tail V2768) (if (not (shen.return? W2770)) (shen.comb W2771 shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2769) (shen.parse-failure) W2769)))

(defun shen.<returns> (V2772) (let W2773 (let W2774 (shen.<return> V2772) (if (shen.parse-failure? W2774) (shen.parse-failure) (let W2775 (shen.in-> W2774) (let W2776 (shen.<returns> W2775) (if (shen.parse-failure? W2776) (shen.parse-failure) (let W2777 (shen.in-> W2776) (shen.comb W2777 shen.skip))))))) (if (shen.parse-failure? W2773) (let W2778 (let W2779 (shen.<return> V2772) (if (shen.parse-failure? W2779) (shen.parse-failure) (let W2780 (shen.in-> W2779) (shen.comb W2780 shen.skip)))) (if (shen.parse-failure? W2778) (shen.parse-failure) W2778)) W2773)))

(defun shen.<return> (V2781) (let W2782 (if (cons? V2781) (let W2783 (head V2781) (let W2784 (tail V2781) (if (shen.return? W2783) (shen.comb W2784 shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2782) (shen.parse-failure) W2782)))

(defun shen.return? (V2785) (element? V2785 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V2786) (let W2787 (let W2788 (shen.<backslash> V2786) (if (shen.parse-failure? W2788) (shen.parse-failure) (let W2789 (shen.in-> W2788) (let W2790 (shen.<times> W2789) (if (shen.parse-failure? W2790) (shen.parse-failure) (let W2791 (shen.in-> W2790) (let W2792 (shen.<longnatter> W2791) (if (shen.parse-failure? W2792) (shen.parse-failure) (let W2793 (shen.in-> W2792) (shen.comb W2793 shen.skip)))))))))) (if (shen.parse-failure? W2787) (shen.parse-failure) W2787)))

(defun shen.<times> (V2794) (let W2795 (if (shen.hds=? V2794 42) (let W2796 (tail V2794) (shen.comb W2796 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2795) (shen.parse-failure) W2795)))

(defun shen.<longnatter> (V2797) (let W2798 (let W2799 (shen.<comment> V2797) (if (shen.parse-failure? W2799) (shen.parse-failure) (let W2800 (shen.in-> W2799) (let W2801 (shen.<longnatter> W2800) (if (shen.parse-failure? W2801) (shen.parse-failure) (let W2802 (shen.in-> W2801) (shen.comb W2802 shen.skip))))))) (if (shen.parse-failure? W2798) (let W2803 (let W2804 (shen.<times> V2797) (if (shen.parse-failure? W2804) (shen.parse-failure) (let W2805 (shen.in-> W2804) (let W2806 (shen.<backslash> W2805) (if (shen.parse-failure? W2806) (shen.parse-failure) (let W2807 (shen.in-> W2806) (shen.comb W2807 shen.skip))))))) (if (shen.parse-failure? W2803) (let W2808 (if (cons? V2797) (let W2809 (tail V2797) (let W2810 (shen.<longnatter> W2809) (if (shen.parse-failure? W2810) (shen.parse-failure) (let W2811 (shen.in-> W2810) (shen.comb W2811 shen.skip))))) (shen.parse-failure)) (if (shen.parse-failure? W2808) (shen.parse-failure) W2808)) W2803)) W2798)))

(defun shen.<atom> (V2812) (let W2813 (let W2814 (shen.<str> V2812) (if (shen.parse-failure? W2814) (shen.parse-failure) (let W2815 (shen.<-out W2814) (let W2816 (shen.in-> W2814) (shen.comb W2816 W2815))))) (if (shen.parse-failure? W2813) (let W2817 (let W2818 (shen.<number> V2812) (if (shen.parse-failure? W2818) (shen.parse-failure) (let W2819 (shen.<-out W2818) (let W2820 (shen.in-> W2818) (shen.comb W2820 W2819))))) (if (shen.parse-failure? W2817) (let W2821 (let W2822 (shen.<sym> V2812) (if (shen.parse-failure? W2822) (shen.parse-failure) (let W2823 (shen.<-out W2822) (let W2824 (shen.in-> W2822) (shen.comb W2824 (if (= W2823 "<>") (cons vector (cons 0 ())) (intern W2823))))))) (if (shen.parse-failure? W2821) (shen.parse-failure) W2821)) W2817)) W2813)))

(defun shen.<sym> (V2825) (let W2826 (let W2827 (shen.<alpha> V2825) (if (shen.parse-failure? W2827) (shen.parse-failure) (let W2828 (shen.<-out W2827) (let W2829 (shen.in-> W2827) (let W2830 (shen.<alphanums> W2829) (if (shen.parse-failure? W2830) (shen.parse-failure) (let W2831 (shen.<-out W2830) (let W2832 (shen.in-> W2830) (shen.comb W2832 (cn W2828 W2831)))))))))) (if (shen.parse-failure? W2826) (shen.parse-failure) W2826)))

(defun shen.<alpha> (V2833) (let W2834 (if (cons? V2833) (let W2835 (head V2833) (let W2836 (tail V2833) (if (shen.alpha? W2835) (shen.comb W2836 (n->string W2835)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2834) (shen.parse-failure) W2834)))

(defun shen.alpha? (V2837) (or (shen.lowercase? V2837) (or (shen.uppercase? V2837) (shen.misc? V2837))))

(defun shen.lowercase? (V2838) (and (>= V2838 97) (<= V2838 122)))

(defun shen.uppercase? (V2839) (and (>= V2839 65) (<= V2839 90)))

(defun shen.misc? (V2840) (element? V2840 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V2841) (let W2842 (let W2843 (shen.<alphanum> V2841) (if (shen.parse-failure? W2843) (shen.parse-failure) (let W2844 (shen.<-out W2843) (let W2845 (shen.in-> W2843) (let W2846 (shen.<alphanums> W2845) (if (shen.parse-failure? W2846) (shen.parse-failure) (let W2847 (shen.<-out W2846) (let W2848 (shen.in-> W2846) (shen.comb W2848 (cn W2844 W2847)))))))))) (if (shen.parse-failure? W2842) (let W2849 (let W2850 (<e> V2841) (if (shen.parse-failure? W2850) (shen.parse-failure) (let W2851 (shen.in-> W2850) (shen.comb W2851 "")))) (if (shen.parse-failure? W2849) (shen.parse-failure) W2849)) W2842)))

(defun shen.<alphanum> (V2852) (let W2853 (let W2854 (shen.<alpha> V2852) (if (shen.parse-failure? W2854) (shen.parse-failure) (let W2855 (shen.<-out W2854) (let W2856 (shen.in-> W2854) (shen.comb W2856 W2855))))) (if (shen.parse-failure? W2853) (let W2857 (let W2858 (shen.<numeral> V2852) (if (shen.parse-failure? W2858) (shen.parse-failure) (let W2859 (shen.<-out W2858) (let W2860 (shen.in-> W2858) (shen.comb W2860 W2859))))) (if (shen.parse-failure? W2857) (shen.parse-failure) W2857)) W2853)))

(defun shen.<numeral> (V2861) (let W2862 (if (cons? V2861) (let W2863 (head V2861) (let W2864 (tail V2861) (if (shen.digit? W2863) (shen.comb W2864 (n->string W2863)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2862) (shen.parse-failure) W2862)))

(defun shen.digit? (V2865) (and (>= V2865 48) (<= V2865 57)))

(defun shen.<str> (V2866) (let W2867 (let W2868 (shen.<dbq> V2866) (if (shen.parse-failure? W2868) (shen.parse-failure) (let W2869 (shen.in-> W2868) (let W2870 (shen.<strcontents> W2869) (if (shen.parse-failure? W2870) (shen.parse-failure) (let W2871 (shen.<-out W2870) (let W2872 (shen.in-> W2870) (let W2873 (shen.<dbq> W2872) (if (shen.parse-failure? W2873) (shen.parse-failure) (let W2874 (shen.in-> W2873) (shen.comb W2874 W2871))))))))))) (if (shen.parse-failure? W2867) (shen.parse-failure) W2867)))

(defun shen.<dbq> (V2875) (let W2876 (if (shen.hds=? V2875 34) (let W2877 (tail V2875) (shen.comb W2877 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2876) (shen.parse-failure) W2876)))

(defun shen.<strcontents> (V2878) (let W2879 (let W2880 (shen.<strc> V2878) (if (shen.parse-failure? W2880) (shen.parse-failure) (let W2881 (shen.<-out W2880) (let W2882 (shen.in-> W2880) (let W2883 (shen.<strcontents> W2882) (if (shen.parse-failure? W2883) (shen.parse-failure) (let W2884 (shen.<-out W2883) (let W2885 (shen.in-> W2883) (shen.comb W2885 (cn W2881 W2884)))))))))) (if (shen.parse-failure? W2879) (let W2886 (let W2887 (<e> V2878) (if (shen.parse-failure? W2887) (shen.parse-failure) (let W2888 (shen.in-> W2887) (shen.comb W2888 "")))) (if (shen.parse-failure? W2886) (shen.parse-failure) W2886)) W2879)))

(defun shen.<strc> (V2889) (let W2890 (let W2891 (shen.<control> V2889) (if (shen.parse-failure? W2891) (shen.parse-failure) (let W2892 (shen.<-out W2891) (let W2893 (shen.in-> W2891) (shen.comb W2893 W2892))))) (if (shen.parse-failure? W2890) (let W2894 (let W2895 (shen.<notdbq> V2889) (if (shen.parse-failure? W2895) (shen.parse-failure) (let W2896 (shen.<-out W2895) (let W2897 (shen.in-> W2895) (shen.comb W2897 W2896))))) (if (shen.parse-failure? W2894) (shen.parse-failure) W2894)) W2890)))

(defun shen.<control> (V2898) (let W2899 (let W2900 (shen.<lowC> V2898) (if (shen.parse-failure? W2900) (shen.parse-failure) (let W2901 (shen.in-> W2900) (let W2902 (shen.<hash> W2901) (if (shen.parse-failure? W2902) (shen.parse-failure) (let W2903 (shen.in-> W2902) (let W2904 (shen.<integer> W2903) (if (shen.parse-failure? W2904) (shen.parse-failure) (let W2905 (shen.<-out W2904) (let W2906 (shen.in-> W2904) (let W2907 (shen.<semicolon> W2906) (if (shen.parse-failure? W2907) (shen.parse-failure) (let W2908 (shen.in-> W2907) (shen.comb W2908 (n->string W2905))))))))))))))) (if (shen.parse-failure? W2899) (shen.parse-failure) W2899)))

(defun shen.<notdbq> (V2909) (let W2910 (if (cons? V2909) (let W2911 (head V2909) (let W2912 (tail V2909) (if (not (= W2911 34)) (shen.comb W2912 (n->string W2911)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2910) (shen.parse-failure) W2910)))

(defun shen.<lowC> (V2913) (let W2914 (if (shen.hds=? V2913 99) (let W2915 (tail V2913) (shen.comb W2915 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2914) (shen.parse-failure) W2914)))

(defun shen.<hash> (V2916) (let W2917 (if (shen.hds=? V2916 35) (let W2918 (tail V2916) (shen.comb W2918 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2917) (shen.parse-failure) W2917)))

(defun shen.<number> (V2919) (let W2920 (let W2921 (shen.<minus> V2919) (if (shen.parse-failure? W2921) (shen.parse-failure) (let W2922 (shen.in-> W2921) (let W2923 (shen.<number> W2922) (if (shen.parse-failure? W2923) (shen.parse-failure) (let W2924 (shen.<-out W2923) (let W2925 (shen.in-> W2923) (shen.comb W2925 (- 0 W2924))))))))) (if (shen.parse-failure? W2920) (let W2926 (let W2927 (shen.<plus> V2919) (if (shen.parse-failure? W2927) (shen.parse-failure) (let W2928 (shen.in-> W2927) (let W2929 (shen.<number> W2928) (if (shen.parse-failure? W2929) (shen.parse-failure) (let W2930 (shen.<-out W2929) (let W2931 (shen.in-> W2929) (shen.comb W2931 W2930)))))))) (if (shen.parse-failure? W2926) (let W2932 (let W2933 (shen.<e-number> V2919) (if (shen.parse-failure? W2933) (shen.parse-failure) (let W2934 (shen.<-out W2933) (let W2935 (shen.in-> W2933) (shen.comb W2935 W2934))))) (if (shen.parse-failure? W2932) (let W2936 (let W2937 (shen.<float> V2919) (if (shen.parse-failure? W2937) (shen.parse-failure) (let W2938 (shen.<-out W2937) (let W2939 (shen.in-> W2937) (shen.comb W2939 W2938))))) (if (shen.parse-failure? W2936) (let W2940 (let W2941 (shen.<integer> V2919) (if (shen.parse-failure? W2941) (shen.parse-failure) (let W2942 (shen.<-out W2941) (let W2943 (shen.in-> W2941) (shen.comb W2943 W2942))))) (if (shen.parse-failure? W2940) (shen.parse-failure) W2940)) W2936)) W2932)) W2926)) W2920)))

(defun shen.<minus> (V2944) (let W2945 (if (shen.hds=? V2944 45) (let W2946 (tail V2944) (shen.comb W2946 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2945) (shen.parse-failure) W2945)))

(defun shen.<plus> (V2947) (let W2948 (if (shen.hds=? V2947 43) (let W2949 (tail V2947) (shen.comb W2949 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2948) (shen.parse-failure) W2948)))

(defun shen.<integer> (V2950) (let W2951 (let W2952 (shen.<digits> V2950) (if (shen.parse-failure? W2952) (shen.parse-failure) (let W2953 (shen.<-out W2952) (let W2954 (shen.in-> W2952) (shen.comb W2954 (shen.compute-integer W2953)))))) (if (shen.parse-failure? W2951) (shen.parse-failure) W2951)))

(defun shen.<digits> (V2955) (let W2956 (let W2957 (shen.<digit> V2955) (if (shen.parse-failure? W2957) (shen.parse-failure) (let W2958 (shen.<-out W2957) (let W2959 (shen.in-> W2957) (let W2960 (shen.<digits> W2959) (if (shen.parse-failure? W2960) (shen.parse-failure) (let W2961 (shen.<-out W2960) (let W2962 (shen.in-> W2960) (shen.comb W2962 (cons W2958 W2961)))))))))) (if (shen.parse-failure? W2956) (let W2963 (let W2964 (shen.<digit> V2955) (if (shen.parse-failure? W2964) (shen.parse-failure) (let W2965 (shen.<-out W2964) (let W2966 (shen.in-> W2964) (shen.comb W2966 (cons W2965 ())))))) (if (shen.parse-failure? W2963) (shen.parse-failure) W2963)) W2956)))

(defun shen.<digit> (V2967) (let W2968 (if (cons? V2967) (let W2969 (head V2967) (let W2970 (tail V2967) (if (shen.digit? W2969) (shen.comb W2970 (shen.byte->digit W2969)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2968) (shen.parse-failure) W2968)))

(defun shen.byte->digit (V2971) (- V2971 48))

(defun shen.compute-integer (V2972) (shen.compute-integer-h (reverse V2972) 0))

(defun shen.compute-integer-h (V2975 V2976) (cond ((= () V2975) 0) ((cons? V2975) (+ (* (shen.expt 10 V2976) (hd V2975)) (shen.compute-integer-h (tl V2975) (+ V2976 1)))) (true (shen.f-error shen.compute-integer-h))))

(defun shen.expt (V2979 V2980) (cond ((= 0 V2980) 1) ((> V2980 0) (* V2979 (shen.expt V2979 (- V2980 1)))) (true (/ (shen.expt V2979 (+ V2980 1)) V2979))))

(defun shen.<float> (V2981) (let W2982 (let W2983 (shen.<integer> V2981) (if (shen.parse-failure? W2983) (shen.parse-failure) (let W2984 (shen.<-out W2983) (let W2985 (shen.in-> W2983) (let W2986 (shen.<stop> W2985) (if (shen.parse-failure? W2986) (shen.parse-failure) (let W2987 (shen.in-> W2986) (let W2988 (shen.<fraction> W2987) (if (shen.parse-failure? W2988) (shen.parse-failure) (let W2989 (shen.<-out W2988) (let W2990 (shen.in-> W2988) (shen.comb W2990 (+ W2984 W2989))))))))))))) (if (shen.parse-failure? W2982) (let W2991 (let W2992 (shen.<stop> V2981) (if (shen.parse-failure? W2992) (shen.parse-failure) (let W2993 (shen.in-> W2992) (let W2994 (shen.<fraction> W2993) (if (shen.parse-failure? W2994) (shen.parse-failure) (let W2995 (shen.<-out W2994) (let W2996 (shen.in-> W2994) (shen.comb W2996 W2995)))))))) (if (shen.parse-failure? W2991) (shen.parse-failure) W2991)) W2982)))

(defun shen.<stop> (V2997) (let W2998 (if (shen.hds=? V2997 46) (let W2999 (tail V2997) (shen.comb W2999 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2998) (shen.parse-failure) W2998)))

(defun shen.<fraction> (V3000) (let W3001 (let W3002 (shen.<digits> V3000) (if (shen.parse-failure? W3002) (shen.parse-failure) (let W3003 (shen.<-out W3002) (let W3004 (shen.in-> W3002) (shen.comb W3004 (shen.compute-fraction W3003)))))) (if (shen.parse-failure? W3001) (shen.parse-failure) W3001)))

(defun shen.compute-fraction (V3005) (shen.compute-fraction-h V3005 -1))

(defun shen.compute-fraction-h (V3008 V3009) (cond ((= () V3008) 0) ((cons? V3008) (+ (* (shen.expt 10 V3009) (hd V3008)) (shen.compute-fraction-h (tl V3008) (- V3009 1)))) (true (shen.f-error shen.compute-fraction-h))))

(defun shen.<e-number> (V3010) (let W3011 (let W3012 (shen.<float> V3010) (if (shen.parse-failure? W3012) (shen.parse-failure) (let W3013 (shen.<-out W3012) (let W3014 (shen.in-> W3012) (let W3015 (shen.<lowE> W3014) (if (shen.parse-failure? W3015) (shen.parse-failure) (let W3016 (shen.in-> W3015) (let W3017 (shen.<log10> W3016) (if (shen.parse-failure? W3017) (shen.parse-failure) (let W3018 (shen.<-out W3017) (let W3019 (shen.in-> W3017) (shen.comb W3019 (shen.compute-E W3013 W3018))))))))))))) (if (shen.parse-failure? W3011) (let W3020 (let W3021 (shen.<integer> V3010) (if (shen.parse-failure? W3021) (shen.parse-failure) (let W3022 (shen.<-out W3021) (let W3023 (shen.in-> W3021) (let W3024 (shen.<lowE> W3023) (if (shen.parse-failure? W3024) (shen.parse-failure) (let W3025 (shen.in-> W3024) (let W3026 (shen.<log10> W3025) (if (shen.parse-failure? W3026) (shen.parse-failure) (let W3027 (shen.<-out W3026) (let W3028 (shen.in-> W3026) (shen.comb W3028 (shen.compute-E W3022 W3027))))))))))))) (if (shen.parse-failure? W3020) (shen.parse-failure) W3020)) W3011)))

(defun shen.<log10> (V3029) (let W3030 (let W3031 (shen.<plus> V3029) (if (shen.parse-failure? W3031) (shen.parse-failure) (let W3032 (shen.in-> W3031) (let W3033 (shen.<log10> W3032) (if (shen.parse-failure? W3033) (shen.parse-failure) (let W3034 (shen.<-out W3033) (let W3035 (shen.in-> W3033) (shen.comb W3035 W3034)))))))) (if (shen.parse-failure? W3030) (let W3036 (let W3037 (shen.<minus> V3029) (if (shen.parse-failure? W3037) (shen.parse-failure) (let W3038 (shen.in-> W3037) (let W3039 (shen.<log10> W3038) (if (shen.parse-failure? W3039) (shen.parse-failure) (let W3040 (shen.<-out W3039) (let W3041 (shen.in-> W3039) (shen.comb W3041 (- 0 W3040))))))))) (if (shen.parse-failure? W3036) (let W3042 (let W3043 (shen.<integer> V3029) (if (shen.parse-failure? W3043) (shen.parse-failure) (let W3044 (shen.<-out W3043) (let W3045 (shen.in-> W3043) (shen.comb W3045 W3044))))) (if (shen.parse-failure? W3042) (shen.parse-failure) W3042)) W3036)) W3030)))

(defun shen.<lowE> (V3046) (let W3047 (if (shen.hds=? V3046 101) (let W3048 (tail V3046) (shen.comb W3048 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W3047) (shen.parse-failure) W3047)))

(defun shen.compute-E (V3049 V3050) (* V3049 (shen.expt 10 V3050)))

(defun shen.<whitespaces> (V3051) (let W3052 (let W3053 (shen.<whitespace> V3051) (if (shen.parse-failure? W3053) (shen.parse-failure) (let W3054 (shen.in-> W3053) (let W3055 (shen.<whitespaces> W3054) (if (shen.parse-failure? W3055) (shen.parse-failure) (let W3056 (shen.in-> W3055) (shen.comb W3056 shen.skip))))))) (if (shen.parse-failure? W3052) (let W3057 (let W3058 (shen.<whitespace> V3051) (if (shen.parse-failure? W3058) (shen.parse-failure) (let W3059 (shen.in-> W3058) (shen.comb W3059 shen.skip)))) (if (shen.parse-failure? W3057) (shen.parse-failure) W3057)) W3052)))

(defun shen.<whitespace> (V3060) (let W3061 (if (cons? V3060) (let W3062 (head V3060) (let W3063 (tail V3060) (if (shen.whitespace? W3062) (shen.comb W3063 shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3061) (shen.parse-failure) W3061)))

(defun shen.whitespace? (V3066) (cond ((= 32 V3066) true) ((= 13 V3066) true) ((= 10 V3066) true) ((= 9 V3066) true) (true false)))

(defun shen.unpackage&macroexpand (V3067) (cond ((= () V3067) ()) ((and (cons? V3067) (shen.packaged? (hd V3067))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V3067)) (tl V3067)))) ((cons? V3067) (let W3068 (macroexpand (hd V3067)) (if (shen.packaged? W3068) (shen.unpackage&macroexpand (cons W3068 (tl V3067))) (cons W3068 (shen.unpackage&macroexpand (tl V3067)))))) (true (shen.f-error shen.unpackage&macroexpand))))

(defun shen.packaged? (V3071) (cond ((and (cons? V3071) (and (= package (hd V3071)) (and (cons? (tl V3071)) (cons? (tl (tl V3071)))))) true) (true false)))

(defun shen.unpackage (V3074) (cond ((and (cons? V3074) (and (= package (hd V3074)) (and (cons? (tl V3074)) (and (= null (hd (tl V3074))) (cons? (tl (tl V3074))))))) (tl (tl (tl V3074)))) ((and (cons? V3074) (and (= package (hd V3074)) (and (cons? (tl V3074)) (cons? (tl (tl V3074)))))) (let W3075 (eval (hd (tl (tl V3074)))) (let W3076 (shen.package-symbols (str (hd (tl V3074))) W3075 (tl (tl (tl V3074)))) (let W3077 (shen.record-external (hd (tl V3074)) W3075) (let W3078 (shen.record-internal (hd (tl V3074)) W3075 (tl (tl (tl V3074)))) W3076))))) (true (shen.f-error shen.unpackage))))

(defun shen.record-internal (V3079 V3080 V3081) (put V3079 shen.internal-symbols (shen.internal-symbols (str V3079) V3080 V3081) (value *property-vector*)))

(defun shen.internal-symbols (V3088 V3089 V3090) (cond ((cons? V3090) (union (shen.internal-symbols V3088 V3089 (hd V3090)) (shen.internal-symbols V3088 V3089 (tl V3090)))) ((shen.internal? V3090 V3088 V3089) (cons (shen.intern-in-package V3088 V3090) ())) (true ())))

(defun shen.record-external (V3091 V3092) (let W3093 (trap-error (get V3091 shen.external-symbols (value *property-vector*)) (lambda Z3094 ())) (put V3091 shen.external-symbols (union V3092 W3093) (value *property-vector*))))

(defun shen.package-symbols (V3099 V3100 V3101) (cond ((cons? V3101) (map (lambda Z3102 (shen.package-symbols V3099 V3100 Z3102)) V3101)) ((shen.internal? V3101 V3099 V3100) (shen.intern-in-package V3099 V3101)) (true V3101)))

(defun shen.intern-in-package (V3103 V3104) (intern (@s V3103 (@s "." (str V3104)))))

(defun shen.internal? (V3105 V3106 V3107) (and (not (element? V3105 V3107)) (and (not (shen.sng? V3105)) (and (not (shen.dbl? V3105)) (and (symbol? V3105) (and (not (shen.sysfunc? V3105)) (and (not (variable? V3105)) (and (not (shen.internal-to-shen? (str V3105))) (not (shen.internal-to-P? V3106 (str V3105)))))))))))

(defun shen.internal-to-shen? (V3112) (cond ((and (shen.+string? V3112) (and (= "s" (hdstr V3112)) (and (shen.+string? (tlstr V3112)) (and (= "h" (hdstr (tlstr V3112))) (and (shen.+string? (tlstr (tlstr V3112))) (and (= "e" (hdstr (tlstr (tlstr V3112)))) (and (shen.+string? (tlstr (tlstr (tlstr V3112)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V3112))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V3112))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V3112))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V3113) (element? V3113 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V3121 V3122) (cond ((and (= "" V3121) (and (shen.+string? V3122) (= "." (hdstr V3122)))) true) ((and (shen.+string? V3121) (and (shen.+string? V3122) (= (hdstr V3121) (hdstr V3122)))) (shen.internal-to-P? (tlstr V3121) (tlstr V3122))) (true false)))

(defun shen.process-applications (V3125 V3126) (cond ((element? V3125 V3126) V3125) ((and (cons? V3125) (= cond (hd V3125))) (cons cond (shen.process-cond-clauses (tl V3125) V3126))) ((and (cons? V3125) (shen.non-application? (hd V3125))) (shen.special-case (hd V3125) V3125 V3126)) ((cons? V3125) (shen.process-application (map (lambda Z3127 (shen.process-applications Z3127 V3126)) V3125) V3126)) (true V3125)))

(defun shen.non-application? (V3130) (cond ((= define V3130) true) ((= defun V3130) true) ((= synonyms V3130) true) ((shen.special? V3130) true) ((shen.extraspecial? V3130) true) (true false)))

(defun shen.special-case (V3135 V3136 V3137) (cond ((and (= lambda V3135) (and (cons? V3136) (and (= lambda (hd V3136)) (and (cons? (tl V3136)) (and (cons? (tl (tl V3136))) (= () (tl (tl (tl V3136))))))))) (cons lambda (cons (hd (tl V3136)) (cons (shen.process-applications (hd (tl (tl V3136))) V3137) ())))) ((and (= let V3135) (and (cons? V3136) (and (= let (hd V3136)) (and (cons? (tl V3136)) (and (cons? (tl (tl V3136))) (and (cons? (tl (tl (tl V3136)))) (= () (tl (tl (tl (tl V3136))))))))))) (cons let (cons (hd (tl V3136)) (cons (shen.process-applications (hd (tl (tl V3136))) V3137) (cons (shen.process-applications (hd (tl (tl (tl V3136)))) V3137) ()))))) ((and (= defun V3135) (and (cons? V3136) (and (= defun (hd V3136)) (and (cons? (tl V3136)) (and (cons? (tl (tl V3136))) (and (cons? (tl (tl (tl V3136)))) (= () (tl (tl (tl (tl V3136))))))))))) V3136) ((and (= define V3135) (and (cons? V3136) (and (= define (hd V3136)) (and (cons? (tl V3136)) (and (cons? (tl (tl V3136))) (= { (hd (tl (tl V3136))))))))) (cons define (cons (hd (tl V3136)) (cons { (shen.process-after-type (hd (tl V3136)) (tl (tl (tl V3136))) V3137))))) ((and (= define V3135) (and (cons? V3136) (and (= define (hd V3136)) (cons? (tl V3136))))) (cons define (cons (hd (tl V3136)) (map (lambda Z3138 (shen.process-applications Z3138 V3137)) (tl (tl V3136)))))) ((= synonyms V3135) (cons synonyms V3136)) ((and (= type V3135) (and (cons? V3136) (and (= type (hd V3136)) (and (cons? (tl V3136)) (and (cons? (tl (tl V3136))) (= () (tl (tl (tl V3136))))))))) (cons type (cons (shen.process-applications (hd (tl V3136)) V3137) (tl (tl V3136))))) ((and (= input+ V3135) (and (cons? V3136) (and (= input+ (hd V3136)) (and (cons? (tl V3136)) (and (cons? (tl (tl V3136))) (= () (tl (tl (tl V3136))))))))) (cons input+ (cons (hd (tl V3136)) (cons (shen.process-applications (hd (tl (tl V3136))) V3137) ())))) ((and (cons? V3136) (shen.special? (hd V3136))) (cons (hd V3136) (map (lambda Z3139 (shen.process-applications Z3139 V3137)) (tl V3136)))) ((and (cons? V3136) (shen.extraspecial? (hd V3136))) V3136) (true (shen.f-error shen.special-case))))

(defun shen.process-cond-clauses (V3142 V3143) (cond ((= () V3142) ()) ((and (cons? V3142) (and (cons? (hd V3142)) (and (cons? (tl (hd V3142))) (= () (tl (tl (hd V3142))))))) (cons (cons (shen.process-applications (hd (hd V3142)) V3143) (cons (shen.process-applications (hd (tl (hd V3142))) V3143) ())) (shen.process-cond-clauses (tl V3142) V3143))) (true (shen.f-error shen.process-cond-clauses))))

(defun shen.process-after-type (V3146 V3147 V3148) (cond ((and (cons? V3147) (= } (hd V3147))) (cons } (map (lambda Z3149 (shen.process-applications Z3149 V3148)) (tl V3147)))) ((cons? V3147) (cons (hd V3147) (shen.process-after-type V3146 (tl V3147) V3148))) (true (simple-error (cn "missing } in " (shen.app V3146 "
" shen.a))))))

(defun shen.process-application (V3150 V3151) (cond ((cons? V3150) (let W3152 (arity (hd V3150)) (let W3153 (length (tl V3150)) (if (element? V3150 V3151) V3150 (if (shen.shen-call? (hd V3150)) V3150 (if (shen.foreign? V3150) (shen.unpack-foreign V3150) (if (shen.fn-call? V3150) (shen.fn-call V3150) (if (shen.zero-place? V3150) V3150 (if (shen.undefined-f? (hd V3150) W3152) (shen.simple-curry (cons (cons fn (cons (hd V3150) ())) (tl V3150))) (if (variable? (hd V3150)) (shen.simple-curry V3150) (if (shen.application? (hd V3150)) (shen.simple-curry V3150) (if (shen.partial-application*? (hd V3150) W3152 W3153) (shen.lambda-function V3150 (- W3152 W3153)) (if (shen.overapplication? (hd V3150) W3152 W3153) (shen.simple-curry (cons (cons fn (cons (hd V3150) ())) (tl V3150))) V3150))))))))))))) (true (shen.f-error shen.process-application))))

(defun shen.unpack-foreign (V3154) (cond ((and (cons? V3154) (and (cons? (hd V3154)) (and (= foreign (hd (hd V3154))) (and (cons? (tl (hd V3154))) (= () (tl (tl (hd V3154)))))))) (cons (hd (tl (hd V3154))) (tl V3154))) (true (shen.f-error shen.unpack-foreign))))

(defun shen.foreign? (V3157) (cond ((and (cons? V3157) (and (cons? (hd V3157)) (and (= foreign (hd (hd V3157))) (and (cons? (tl (hd V3157))) (= () (tl (tl (hd V3157)))))))) true) (true false)))

(defun shen.zero-place? (V3160) (cond ((and (cons? V3160) (= () (tl V3160))) true) (true false)))

(defun shen.shen-call? (V3161) (and (symbol? V3161) (shen.internal-to-shen? (str V3161))))

(defun shen.internal-to-shen? (V3166) (cond ((and (shen.+string? V3166) (and (= "s" (hdstr V3166)) (and (shen.+string? (tlstr V3166)) (and (= "h" (hdstr (tlstr V3166))) (and (shen.+string? (tlstr (tlstr V3166))) (and (= "e" (hdstr (tlstr (tlstr V3166)))) (and (shen.+string? (tlstr (tlstr (tlstr V3166)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V3166))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V3166))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V3166))))))))))))))) true) (true false)))

(defun shen.application? (V3171) (cond ((and (cons? V3171) (and (= protect (hd V3171)) (and (cons? (tl V3171)) (= () (tl (tl V3171)))))) false) ((and (cons? V3171) (and (= foreign (hd V3171)) (and (cons? (tl V3171)) (= () (tl (tl V3171)))))) false) (true (cons? V3171))))

(defun shen.undefined-f? (V3176 V3177) (cond ((= -1 V3177) (and (shen.lowercase-symbol? V3176) (not (element? V3176 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V3178) (and (symbol? V3178) (not (variable? V3178))))

(defun shen.simple-curry (V3179) (cond ((and (cons? V3179) (and (cons? (tl V3179)) (= () (tl (tl V3179))))) V3179) ((and (cons? V3179) (and (cons? (tl V3179)) (cons? (tl (tl V3179))))) (shen.simple-curry (cons (cons (hd V3179) (cons (hd (tl V3179)) ())) (tl (tl V3179))))) (true V3179)))

(defun function (V3180) (fn V3180))

(defun fn (V3181) (trap-error (get V3181 shen.lambda-form (value *property-vector*)) (lambda Z3182 (simple-error (cn "fn: " (shen.app V3181 " is undefined
" shen.a))))))

(defun shen.fn-call? (V3185) (cond ((and (cons? V3185) (and (= fn (hd V3185)) (and (cons? (tl V3185)) (= () (tl (tl V3185)))))) true) ((and (cons? V3185) (and (= function (hd V3185)) (and (cons? (tl V3185)) (= () (tl (tl V3185)))))) true) (true false)))

(defun shen.fn-call (V3186) (cond ((and (cons? V3186) (and (= function (hd V3186)) (and (cons? (tl V3186)) (= () (tl (tl V3186)))))) (shen.fn-call (cons fn (tl V3186)))) ((and (cons? V3186) (and (= fn (hd V3186)) (and (cons? (tl V3186)) (= () (tl (tl V3186)))))) (let W3187 (arity (hd (tl V3186))) (if (= W3187 -1) V3186 (if (= W3187 0) (simple-error "fn cannot be applied to a zero place function
") (shen.lambda-function (tl V3186) W3187))))) (true (shen.f-error shen.fn-call))))

(defun shen.partial-application*? (V3188 V3189 V3190) (let W3191 (> V3189 V3190) (let W3192 (if (and W3191 (and (shen.loading?) (not (element? V3188 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V3188 "
" shen.a)) (stoutput)) shen.skip) W3191)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V3197 V3198 V3199) (cond ((= -1 V3198) false) (true (let W3200 (< V3198 V3199) (let W3201 (if (and W3200 (shen.loading?)) (pr (shen.app V3197 (cn " might not like " (shen.app V3199 (cn " argument" (shen.app (if (= V3199 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) W3200)))))

