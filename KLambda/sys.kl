(defun thaw (V10364) (V10364))

(defun eval (V10365) (eval-kl (shen.shen->kl (shen.process-applications (macroexpand V10365) (shen.find-types V10365)))))

(defun external (V10366) (cond ((= null V10366) ()) (true (trap-error (get V10366 shen.external-symbols (value *property-vector*)) (lambda Z10367 (simple-error (cn "package " (shen.app V10366 " does not exist.
;" shen.a))))))))

(defun internal (V10368) (cond ((= null V10368) ()) (true (trap-error (get V10368 shen.internal-symbols (value *property-vector*)) (lambda Z10369 (simple-error (cn "package " (shen.app V10368 " does not exist.
;" shen.a))))))))

(defun fail-if (V10370 V10371) (if (V10370 V10371) (fail) V10371))

(defun @s (V10372 V10373) (cn V10372 V10373))

(defun tc? () (value shen.*tc*))

(defun ps (V10374) (trap-error (get V10374 shen.source (value *property-vector*)) (lambda Z10375 (simple-error (shen.app V10374 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun vector (V10376) (let W10377 (absvector (+ V10376 1)) (let W10378 (address-> W10377 0 V10376) (let W10379 (if (= V10376 0) W10378 (shen.fillvector W10378 1 V10376 (fail))) W10379))))

(defun shen.fillvector (V10381 V10382 V10383 V10384) (cond ((= V10382 V10383) (address-> V10381 V10383 V10384)) (true (shen.fillvector (address-> V10381 V10382 V10384) (+ 1 V10382) V10383 V10384))))

(defun vector? (V10385) (and (absvector? V10385) (trap-error (>= (<-address V10385 0) 0) (lambda Z10386 false))))

(defun vector-> (V10387 V10388 V10389) (if (= V10388 0) (simple-error "cannot access 0th element of a vector
") (address-> V10387 V10388 V10389)))

(defun <-vector (V10390 V10391) (if (= V10391 0) (simple-error "cannot access 0th element of a vector
") (let W10392 (<-address V10390 V10391) (if (= W10392 (fail)) (simple-error "vector element not found
") W10392))))

(defun shen.posint? (V10393) (and (integer? V10393) (>= V10393 0)))

(defun limit (V10394) (<-address V10394 0))

(defun symbol? (V10395) (cond ((or (boolean? V10395) (or (number? V10395) (or (string? V10395) (or (cons? V10395) (or (empty? V10395) (vector? V10395)))))) false) ((element? V10395 (cons { (cons } (cons (intern ":") (cons (intern ";") (cons (intern ",") ())))))) true) (true (trap-error (let W10396 (str V10395) (shen.analyse-symbol? W10396)) (lambda Z10397 false)))))

(defun shen.analyse-symbol? (V10400) (cond ((shen.+string? V10400) (and (shen.alpha? (string->n (hdstr V10400))) (shen.alphanums? (tlstr V10400)))) (true (simple-error "implementation error in shen.analyse-symbol?"))))

(defun shen.alphanums? (V10403) (cond ((= "" V10403) true) ((shen.+string? V10403) (let W10404 (string->n (hdstr V10403)) (and (or (shen.alpha? W10404) (shen.digit? W10404)) (shen.alphanums? (tlstr V10403))))) (true (simple-error "implementation error in shen.alphanums?"))))

(defun variable? (V10405) (cond ((or (boolean? V10405) (or (number? V10405) (string? V10405))) false) (true (trap-error (let W10406 (str V10405) (shen.analyse-variable? W10406)) (lambda Z10407 false)))))

(defun shen.analyse-variable? (V10410) (cond ((shen.+string? V10410) (and (shen.uppercase? (string->n (hdstr V10410))) (shen.alphanums? (tlstr V10410)))) (true (simple-error "implementation error in shen.analyse-variable?"))))

(defun gensym (V10411) (concat V10411 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V10412 V10413) (intern (cn (str V10412) (str V10413))))

(defun @p (V10414 V10415) (let W10416 (absvector 3) (let W10417 (address-> W10416 0 shen.tuple) (let W10418 (address-> W10416 1 V10414) (let W10419 (address-> W10416 2 V10415) W10416)))))

(defun fst (V10420) (<-address V10420 1))

(defun snd (V10421) (<-address V10421 2))

(defun tuple? (V10422) (trap-error (and (absvector? V10422) (= shen.tuple (<-address V10422 0))) (lambda Z10423 false)))

(defun append (V10428 V10429) (cond ((= () V10428) V10429) ((cons? V10428) (cons (hd V10428) (append (tl V10428) V10429))) (true (simple-error "attempt to append a non-list"))))

(defun @v (V10430 V10431) (let W10432 (limit V10431) (let W10433 (vector (+ W10432 1)) (let W10434 (vector-> W10433 1 V10430) (if (= W10432 0) W10434 (shen.@v-help V10431 1 W10432 W10434))))))

(defun shen.@v-help (V10436 V10437 V10438 V10439) (cond ((= V10437 V10438) (shen.copyfromvector V10436 V10439 V10438 (+ V10438 1))) (true (shen.@v-help V10436 (+ V10437 1) V10438 (shen.copyfromvector V10436 V10439 V10437 (+ V10437 1))))))

(defun shen.copyfromvector (V10440 V10441 V10442 V10443) (trap-error (vector-> V10441 V10443 (<-vector V10440 V10442)) (lambda Z10444 V10441)))

(defun hdv (V10445) (trap-error (<-vector V10445 1) (lambda Z10446 (simple-error "hdv needs a non-empty vector as an argument
"))))

(defun tlv (V10447) (let W10448 (limit V10447) (if (= W10448 0) (simple-error "cannot take the tail of the empty vector
") (if (= W10448 1) (vector 0) (let W10449 (vector (- W10448 1)) (shen.tlv-help V10447 2 W10448 (vector (- W10448 1))))))))

(defun shen.tlv-help (V10451 V10452 V10453 V10454) (cond ((= V10452 V10453) (shen.copyfromvector V10451 V10454 V10453 (- V10453 1))) (true (shen.tlv-help V10451 (+ V10452 1) V10453 (shen.copyfromvector V10451 V10454 V10452 (- V10452 1))))))

(defun assoc (V10466 V10467) (cond ((= () V10467) ()) ((and (cons? V10467) (and (cons? (hd V10467)) (= V10466 (hd (hd V10467))))) (hd V10467)) ((cons? V10467) (assoc V10466 (tl V10467))) (true (simple-error "attempt to search a non-list with assoc
"))))

(defun boolean? (V10470) (cond ((= true V10470) true) ((= false V10470) true) (true false)))

(defun nl (V10471) (cond ((= 0 V10471) 0) (true (do (pr "
" (stoutput)) (nl (- V10471 1))))))

(defun difference (V10478 V10479) (cond ((= () V10478) ()) ((cons? V10478) (if (element? (hd V10478) V10479) (difference (tl V10478) V10479) (cons (hd V10478) (difference (tl V10478) V10479)))) (true (simple-error "attempt to find the difference with a non-list
"))))

(defun do (V10480 V10481) V10481)

(defun element? (V10493 V10494) (cond ((= () V10494) false) ((and (cons? V10494) (= V10493 (hd V10494))) true) ((cons? V10494) (element? V10493 (tl V10494))) (true (simple-error "attempt to find an element in a non-list
"))))

(defun empty? (V10497) (cond ((= () V10497) true) (true false)))

(defun fix (V10498 V10499) (shen.fix-help V10498 V10499 (V10498 V10499)))

(defun shen.fix-help (V10505 V10506 V10507) (cond ((= V10506 V10507) V10507) (true (shen.fix-help V10505 V10507 (V10505 V10507)))))

(defun put (V10508 V10509 V10510 V10511) (let W10512 (hash V10508 (limit V10511)) (let W10513 (trap-error (<-vector V10511 W10512) (lambda Z10514 ())) (let W10515 (vector-> V10511 W10512 (shen.change-pointer-value V10508 V10509 V10510 W10513)) V10510))))

(defun unput (V10516 V10517 V10518) (let W10519 (hash V10516 (limit V10518)) (let W10520 (trap-error (<-vector V10518 W10519) (lambda Z10521 ())) (let W10522 (vector-> V10518 W10519 (shen.remove-pointer V10516 V10517 W10520)) V10516))))

(defun shen.remove-pointer (V10533 V10534 V10535) (cond ((= () V10535) ()) ((and (cons? V10535) (and (cons? (hd V10535)) (and (cons? (hd (hd V10535))) (and (cons? (tl (hd (hd V10535)))) (and (= () (tl (tl (hd (hd V10535))))) (and (= V10534 (hd (tl (hd (hd V10535))))) (= V10533 (hd (hd (hd V10535)))))))))) (tl V10535)) ((cons? V10535) (cons (hd V10535) (shen.remove-pointer V10533 V10534 (tl V10535)))) (true (simple-error "implementation error in shen.remove-pointer"))))

(defun shen.change-pointer-value (V10548 V10549 V10550 V10551) (cond ((= () V10551) (cons (cons (cons V10548 (cons V10549 ())) V10550) ())) ((and (cons? V10551) (and (cons? (hd V10551)) (and (cons? (hd (hd V10551))) (and (cons? (tl (hd (hd V10551)))) (and (= () (tl (tl (hd (hd V10551))))) (and (= V10549 (hd (tl (hd (hd V10551))))) (= V10548 (hd (hd (hd V10551)))))))))) (cons (cons (hd (hd V10551)) V10550) (tl V10551))) ((cons? V10551) (cons (hd V10551) (shen.change-pointer-value V10548 V10549 V10550 (tl V10551)))) (true (simple-error "implementation error in shen.change-pointer-value"))))

(defun get (V10552 V10553 V10554) (let W10555 (hash V10552 (limit V10554)) (let W10556 (trap-error (<-vector V10554 W10555) (lambda Z10557 (simple-error (shen.app V10552 (cn " has no attributes: " (shen.app V10553 "
" shen.s)) shen.a)))) (let W10558 (assoc (cons V10552 (cons V10553 ())) W10556) (if (empty? W10558) (simple-error (cn "attribute " (shen.app V10553 (cn " not found for " (shen.app V10552 "
" shen.s)) shen.s))) (tl W10558))))))

(defun hash (V10559 V10560) (let W10561 (shen.mod (shen.hashkey V10559) V10560) (if (= W10561 0) 1 W10561)))

(defun shen.hashkey (V10562) (let W10563 (map (lambda Z10564 (string->n Z10564)) (explode V10562)) (shen.prodbutzero W10563 1)))

(defun shen.prodbutzero (V10565 V10566) (cond ((= () V10565) V10566) ((and (cons? V10565) (= 0 (hd V10565))) (shen.prodbutzero (tl V10565) V10566)) ((cons? V10565) (if (> V10566 10000000000) (shen.prodbutzero (tl V10565) (+ V10566 (hd V10565))) (shen.prodbutzero (tl V10565) (* V10566 (hd V10565))))) (true (simple-error "partial function shen.prodbutzero"))))

(defun shen.mod (V10567 V10568) (shen.modh V10567 (shen.multiples V10567 (cons V10568 ()))))

(defun shen.multiples (V10573 V10574) (cond ((and (cons? V10574) (> (hd V10574) V10573)) (tl V10574)) ((cons? V10574) (shen.multiples V10573 (cons (* 2 (hd V10574)) V10574))) (true (simple-error "implementation error in shen.multiples"))))

(defun shen.modh (V10581 V10582) (cond ((= 0 V10581) 0) ((= () V10582) V10581) ((and (cons? V10582) (> (hd V10582) V10581)) (if (empty? (tl V10582)) V10581 (shen.modh V10581 (tl V10582)))) ((cons? V10582) (shen.modh (- V10581 (hd V10582)) V10582)) (true (simple-error "implementation error in shen.modh"))))

(defun sum (V10585) (cond ((= () V10585) 0) ((cons? V10585) (+ (hd V10585) (sum (tl V10585)))) (true (simple-error "attempt to sum a non-list
"))))

(defun head (V10590) (cond ((cons? V10590) (hd V10590)) (true (simple-error "head expects a non-empty list
"))))

(defun tail (V10595) (cond ((cons? V10595) (tl V10595)) (true (simple-error "tail expects a non-empty list
"))))

(defun hdstr (V10596) (pos V10596 0))

(defun intersection (V10603 V10604) (cond ((= () V10603) ()) ((cons? V10603) (if (element? (hd V10603) V10604) (cons (hd V10603) (intersection (tl V10603) V10604)) (intersection (tl V10603) V10604))) (true (simple-error "attempt to find the intersection with a non-list
"))))

(defun reverse (V10605) (shen.reverse-help V10605 ()))

(defun shen.reverse-help (V10610 V10611) (cond ((= () V10610) V10611) ((cons? V10610) (shen.reverse-help (tl V10610) (cons (hd V10610) V10611))) (true (simple-error "attempt to reverse a non-list
"))))

(defun union (V10616 V10617) (cond ((= () V10616) V10617) ((cons? V10616) (if (element? (hd V10616) V10617) (union (tl V10616) V10617) (cons (hd V10616) (union (tl V10616) V10617)))) (true (simple-error "attempt to find the union with a non-list
"))))

(defun y-or-n? (V10618) (let W10619 (pr (shen.proc-nl V10618) (stoutput)) (let W10620 (pr " (y/n) " (stoutput)) (let W10621 (shen.app (read (stinput)) "" shen.s) (if (= "y" W10621) true (if (= "n" W10621) false (do (pr "please answer y or n
" (stoutput)) (y-or-n? V10618))))))))

(defun not (V10622) (if V10622 false true))

(defun abort () (simple-error ""))

(defun subst (V10628 V10629 V10630) (cond ((= V10629 V10630) V10628) ((cons? V10630) (cons (subst V10628 V10629 (hd V10630)) (subst V10628 V10629 (tl V10630)))) (true V10630)))

(defun explode (V10631) (shen.explode-h (shen.app V10631 "" shen.a)))

(defun shen.explode-h (V10634) (cond ((= "" V10634) ()) ((shen.+string? V10634) (cons (hdstr V10634) (shen.explode-h (tlstr V10634)))) (true (simple-error "implementation error in explode-h"))))

(defun cd (V10635) (set *home-directory* (if (= V10635 "") "" (shen.app V10635 "/" shen.a))))

(defun map (V10636 V10637) (shen.map-h V10636 V10637 ()))

(defun shen.map-h (V10638 V10639 V10640) (cond ((= () V10639) (reverse V10640)) ((cons? V10639) (shen.map-h V10638 (tl V10639) (cons (V10638 (hd V10639)) V10640))) (true (simple-error "partial function shen.map-h"))))

(defun length (V10641) (shen.length-h V10641 0))

(defun shen.length-h (V10646 V10647) (cond ((= () V10646) V10647) (true (shen.length-h (tl V10646) (+ V10647 1)))))

(defun occurrences (V10653 V10654) (cond ((= V10653 V10654) 1) ((cons? V10654) (+ (occurrences V10653 (hd V10654)) (occurrences V10653 (tl V10654)))) (true 0)))

(defun nth (V10659 V10660) (cond ((and (= 1 V10659) (cons? V10660)) (hd V10660)) ((cons? V10660) (nth (- V10659 1) (tl V10660))) (true (simple-error (cn "nth applied to " (shen.app V10659 (cn ", " (shen.app V10660 "
" shen.a)) shen.a))))))

(defun integer? (V10661) (and (number? V10661) (let W10662 (shen.abs V10661) (shen.integer-test? W10662 (shen.magless W10662 1)))))

(defun shen.abs (V10663) (if (> V10663 0) V10663 (- 0 V10663)))

(defun shen.magless (V10664 V10665) (let W10666 (* V10665 2) (if (> W10666 V10664) V10665 (shen.magless V10664 W10666))))

(defun shen.integer-test? (V10670 V10671) (cond ((= 0 V10670) true) ((> 1 V10670) false) (true (let W10672 (- V10670 V10671) (if (> 0 W10672) (integer? V10670) (shen.integer-test? W10672 V10671))))))

(defun mapcan (V10679 V10680) (cond ((= () V10680) ()) ((cons? V10680) (append (V10679 (hd V10680)) (mapcan V10679 (tl V10680)))) (true (simple-error "attempt to mapcan over a non-list
"))))

(defun == (V10686 V10687) (cond ((= V10686 V10687) true) (true false)))

(defun bound? (V10688) (and (symbol? V10688) (let W10689 (trap-error (value V10688) (lambda Z10690 shen.this-symbol-is-unbound)) (if (= W10689 shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V10691) (cond ((= "" V10691) ()) (true (cons (string->n (pos V10691 0)) (shen.string->bytes (tlstr V10691))))))

(defun maxinferences (V10692) (set shen.*maxinferences* V10692))

(defun inferences () (value shen.*infs*))

(defun protect (V10693) V10693)

(defun stoutput () (value *stoutput*))

(defun string->symbol (V10694) (let W10695 (intern V10694) (if (symbol? W10695) W10695 (simple-error (cn "cannot intern " (shen.app V10694 " to a symbol" shen.s))))))

(defun optimise (V10698) (cond ((= + V10698) (set shen.*optimise* true)) ((= - V10698) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V10699) (cond ((= null V10699) true) (true (trap-error (do (external V10699) true) (lambda Z10700 false)))))

(defun fail () shen.fail!)(defun enable-type-theory (V10703) (cond ((= + V10703) (set shen.*shen-type-theory-enabled?* true)) ((= - V10703) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun tc (V10706) (cond ((= + V10706) (set shen.*tc* true)) ((= - V10706) (set shen.*tc* false)) (true (simple-error "tc expects a + or -"))))

(defun destroy (V10707) (do (set shen.*sigf* (shen.unassoc V10707 (value shen.*sigf*))) V10707))

(defun shen.unassoc (V10717 V10718) (cond ((= () V10718) ()) ((and (cons? V10718) (and (cons? (hd V10718)) (= V10717 (hd (hd V10718))))) (tl V10718)) ((cons? V10718) (cons (hd V10718) (shen.unassoc V10717 (tl V10718)))) (true (simple-error "implementation error in shen.unassoc"))))

(defun in-package (V10719) (if (package? V10719) (set shen.*package* V10719) (simple-error (cn "package " (shen.app V10719 " does not exist
" shen.a)))))

(defun write-to-file (V10720 V10721) (let W10722 (open V10720 out) (let W10723 (if (string? V10721) (shen.app V10721 "

" shen.a) (shen.app V10721 "

" shen.s)) (let W10724 (pr W10723 W10722) (let W10725 (close W10722) V10721)))))

(defun fresh () (shen.freshterm (gensym shen.t)))

(defun update-lambda-table (V10726 V10727) (let W10728 (put V10726 arity V10727 (value *property-vector*)) (let W10729 (shen.lambda-entry V10726) (let W10730 (set shen.*lambdatable* (cons W10729 (value shen.*lambdatable*))) V10726))))

(defun specialise (V10733 V10734) (cond ((= 0 V10734) (do (set shen.*special* (remove V10733 (value shen.*special*))) (do (set shen.*extraspecial* (remove V10733 (value shen.*extraspecial*))) V10733))) ((= 1 V10734) (do (set shen.*special* (adjoin V10733 (value shen.*special*))) (do (set shen.*extraspecial* (remove V10733 (value shen.*extraspecial*))) V10733))) ((= 2 V10734) (do (set shen.*special* (remove V10733 (value shen.*special*))) (do (set shen.*extraspecial* (adjoin V10733 (value shen.*extraspecial*))) V10733))) (true (simple-error "specialise requires values of 0, 1 or 2
"))))

