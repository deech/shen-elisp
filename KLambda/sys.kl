(defun thaw (V3807) (V3807))

(defun eval (V3808) (eval-kl (shen.shen->kl (shen.process-applications (macroexpand V3808) (shen.find-types V3808)))))

(defun external (V3809) (cond ((= null V3809) ()) (true (trap-error (get V3809 shen.external-symbols (value *property-vector*)) (lambda Z3810 (simple-error (cn "package " (shen.app V3809 " does not exist.
;" shen.a))))))))

(defun internal (V3811) (cond ((= null V3811) ()) (true (trap-error (get V3811 shen.internal-symbols (value *property-vector*)) (lambda Z3812 (simple-error (cn "package " (shen.app V3811 " does not exist.
;" shen.a))))))))

(defun fail-if (V3813 V3814) (if (V3813 V3814) (fail) V3814))

(defun @s (V3815 V3816) (cn V3815 V3816))

(defun tc? () (value shen.*tc*))

(defun ps (V3817) (trap-error (get V3817 shen.source (value *property-vector*)) (lambda Z3818 (simple-error (shen.app V3817 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun vector (V3819) (let W3820 (absvector (+ V3819 1)) (let W3821 (address-> W3820 0 V3819) (let W3822 (if (= V3819 0) W3821 (shen.fillvector W3821 1 V3819 (fail))) W3822))))

(defun shen.fillvector (V3824 V3825 V3826 V3827) (cond ((= V3825 V3826) (address-> V3824 V3826 V3827)) (true (shen.fillvector (address-> V3824 V3825 V3827) (+ 1 V3825) V3826 V3827))))

(defun vector? (V3828) (and (absvector? V3828) (let W3829 (trap-error (<-address V3828 0) (lambda Z3830 -1)) (and (number? W3829) (>= W3829 0)))))

(defun vector-> (V3831 V3832 V3833) (if (= V3832 0) (simple-error "cannot access 0th element of a vector
") (address-> V3831 V3832 V3833)))

(defun <-vector (V3834 V3835) (if (= V3835 0) (simple-error "cannot access 0th element of a vector
") (let W3836 (<-address V3834 V3835) (if (= W3836 (fail)) (simple-error "vector element not found
") W3836))))

(defun shen.posint? (V3837) (and (integer? V3837) (>= V3837 0)))

(defun limit (V3838) (<-address V3838 0))

(defun symbol? (V3839) (cond ((or (boolean? V3839) (or (number? V3839) (or (string? V3839) (or (cons? V3839) (or (empty? V3839) (vector? V3839)))))) false) ((element? V3839 (cons { (cons } (cons (intern ":") (cons (intern ";") (cons (intern ",") ())))))) true) (true (trap-error (let W3840 (str V3839) (shen.analyse-symbol? W3840)) (lambda Z3841 false)))))

(defun shen.analyse-symbol? (V3844) (cond ((shen.+string? V3844) (and (shen.alpha? (string->n (hdstr V3844))) (shen.alphanums? (tlstr V3844)))) (true (simple-error "implementation error in shen.analyse-symbol?"))))

(defun shen.alphanums? (V3847) (cond ((= "" V3847) true) ((shen.+string? V3847) (let W3848 (string->n (hdstr V3847)) (and (or (shen.alpha? W3848) (shen.digit? W3848)) (shen.alphanums? (tlstr V3847))))) (true (simple-error "implementation error in shen.alphanums?"))))

(defun variable? (V3849) (cond ((or (boolean? V3849) (or (number? V3849) (string? V3849))) false) (true (trap-error (let W3850 (str V3849) (shen.analyse-variable? W3850)) (lambda Z3851 false)))))

(defun shen.analyse-variable? (V3854) (cond ((shen.+string? V3854) (and (shen.uppercase? (string->n (hdstr V3854))) (shen.alphanums? (tlstr V3854)))) (true (simple-error "implementation error in shen.analyse-variable?"))))

(defun gensym (V3855) (concat V3855 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V3856 V3857) (intern (cn (str V3856) (str V3857))))

(defun @p (V3858 V3859) (let W3860 (absvector 3) (let W3861 (address-> W3860 0 shen.tuple) (let W3862 (address-> W3860 1 V3858) (let W3863 (address-> W3860 2 V3859) W3860)))))

(defun fst (V3864) (<-address V3864 1))

(defun snd (V3865) (<-address V3865 2))

(defun tuple? (V3866) (and (absvector? V3866) (= shen.tuple (trap-error (<-address V3866 0) (lambda Z3867 shen.not-tuple)))))

(defun append (V3872 V3873) (cond ((= () V3872) V3873) ((cons? V3872) (cons (hd V3872) (append (tl V3872) V3873))) (true (simple-error "attempt to append a non-list"))))

(defun @v (V3874 V3875) (let W3876 (limit V3875) (let W3877 (vector (+ W3876 1)) (let W3878 (vector-> W3877 1 V3874) (if (= W3876 0) W3878 (shen.@v-help V3875 1 W3876 W3878))))))

(defun shen.@v-help (V3880 V3881 V3882 V3883) (cond ((= V3881 V3882) (shen.copyfromvector V3880 V3883 V3882 (+ V3882 1))) (true (shen.@v-help V3880 (+ V3881 1) V3882 (shen.copyfromvector V3880 V3883 V3881 (+ V3881 1))))))

(defun shen.copyfromvector (V3884 V3885 V3886 V3887) (trap-error (vector-> V3885 V3887 (<-vector V3884 V3886)) (lambda Z3888 V3885)))

(defun hdv (V3889) (trap-error (<-vector V3889 1) (lambda Z3890 (simple-error "hdv needs a non-empty vector as an argument
"))))

(defun tlv (V3891) (let W3892 (limit V3891) (if (= W3892 0) (simple-error "cannot take the tail of the empty vector
") (if (= W3892 1) (vector 0) (let W3893 (vector (- W3892 1)) (shen.tlv-help V3891 2 W3892 (vector (- W3892 1))))))))

(defun shen.tlv-help (V3895 V3896 V3897 V3898) (cond ((= V3896 V3897) (shen.copyfromvector V3895 V3898 V3897 (- V3897 1))) (true (shen.tlv-help V3895 (+ V3896 1) V3897 (shen.copyfromvector V3895 V3898 V3896 (- V3896 1))))))

(defun assoc (V3910 V3911) (cond ((= () V3911) ()) ((and (cons? V3911) (and (cons? (hd V3911)) (= V3910 (hd (hd V3911))))) (hd V3911)) ((cons? V3911) (assoc V3910 (tl V3911))) (true (simple-error "attempt to search a non-list with assoc
"))))

(defun shen.assoc-set (V3915 V3916 V3917) (cond ((= () V3917) (cons (cons V3915 V3916) ())) ((and (cons? V3917) (and (cons? (hd V3917)) (= V3915 (hd (hd V3917))))) (cons (cons (hd (hd V3917)) V3916) (tl V3917))) ((cons? V3917) (cons (hd V3917) (shen.assoc-set V3915 V3916 (tl V3917)))) (true (shen.f-error shen.assoc-set))))

(defun shen.assoc-rm (V3921 V3922) (cond ((= () V3922) ()) ((and (cons? V3922) (and (cons? (hd V3922)) (= V3921 (hd (hd V3922))))) (tl V3922)) ((cons? V3922) (cons (hd V3922) (shen.assoc-rm V3921 (tl V3922)))) (true (shen.f-error shen.assoc-rm))))

(defun boolean? (V3925) (cond ((= true V3925) true) ((= false V3925) true) (true false)))

(defun nl (V3926) (cond ((= 0 V3926) 0) (true (do (pr "
" (stoutput)) (nl (- V3926 1))))))

(defun difference (V3933 V3934) (cond ((= () V3933) ()) ((cons? V3933) (if (element? (hd V3933) V3934) (difference (tl V3933) V3934) (cons (hd V3933) (difference (tl V3933) V3934)))) (true (simple-error "attempt to find the difference with a non-list
"))))

(defun do (V3935 V3936) V3936)

(defun element? (V3948 V3949) (cond ((= () V3949) false) ((and (cons? V3949) (= V3948 (hd V3949))) true) ((cons? V3949) (element? V3948 (tl V3949))) (true (simple-error "attempt to find an element in a non-list
"))))

(defun empty? (V3952) (cond ((= () V3952) true) (true false)))

(defun fix (V3953 V3954) (shen.fix-help V3953 V3954 (V3953 V3954)))

(defun shen.fix-help (V3960 V3961 V3962) (cond ((= V3961 V3962) V3962) (true (shen.fix-help V3960 V3962 (V3960 V3962)))))

(defun put (V3963 V3964 V3965 V3966) (let W3967 (trap-error (shen.<-dict V3966 V3963) (lambda Z3968 ())) (let W3969 (shen.assoc-set V3964 V3965 W3967) (let W3970 (shen.dict-> V3966 V3963 W3969) V3965))))

(defun unput (V3971 V3972 V3973) (let W3974 (trap-error (shen.<-dict V3973 V3971) (lambda Z3975 ())) (let W3976 (shen.assoc-rm V3972 W3974) (let W3977 (shen.dict-> V3973 V3971 W3976) V3971))))

(defun get (V3978 V3979 V3980) (let W3981 (trap-error (shen.<-dict V3980 V3978) (lambda Z3982 (simple-error (shen.app V3978 (cn " has no attributes: " (shen.app V3979 "
" shen.s)) shen.a)))) (let W3983 (assoc V3979 W3981) (if (empty? W3983) (simple-error (cn "attribute " (shen.app V3979 (cn " not found for " (shen.app V3978 "
" shen.s)) shen.s))) (tl W3983)))))

(defun hash (V3984 V3985) (let W3986 (shen.mod (shen.hashkey V3984) V3985) (if (= W3986 0) 1 W3986)))

(defun shen.hashkey (V3987) (let W3988 (map (lambda Z3989 (string->n Z3989)) (explode V3987)) (shen.prodbutzero W3988 1)))

(defun shen.prodbutzero (V3990 V3991) (cond ((= () V3990) V3991) ((and (cons? V3990) (= 0 (hd V3990))) (shen.prodbutzero (tl V3990) V3991)) ((cons? V3990) (if (> V3991 10000000000) (shen.prodbutzero (tl V3990) (+ V3991 (hd V3990))) (shen.prodbutzero (tl V3990) (* V3991 (hd V3990))))) (true (shen.f-error shen.prodbutzero))))

(defun shen.mod (V3992 V3993) (shen.modh V3992 (shen.multiples V3992 (cons V3993 ()))))

(defun shen.multiples (V3998 V3999) (cond ((and (cons? V3999) (> (hd V3999) V3998)) (tl V3999)) ((cons? V3999) (shen.multiples V3998 (cons (* 2 (hd V3999)) V3999))) (true (simple-error "implementation error in shen.multiples"))))

(defun shen.modh (V4006 V4007) (cond ((= 0 V4006) 0) ((= () V4007) V4006) ((and (cons? V4007) (> (hd V4007) V4006)) (if (empty? (tl V4007)) V4006 (shen.modh V4006 (tl V4007)))) ((cons? V4007) (shen.modh (- V4006 (hd V4007)) V4007)) (true (simple-error "implementation error in shen.modh"))))

(defun sum (V4010) (cond ((= () V4010) 0) ((cons? V4010) (+ (hd V4010) (sum (tl V4010)))) (true (simple-error "attempt to sum a non-list
"))))

(defun head (V4015) (cond ((cons? V4015) (hd V4015)) (true (simple-error "head expects a non-empty list
"))))

(defun tail (V4020) (cond ((cons? V4020) (tl V4020)) (true (simple-error "tail expects a non-empty list
"))))

(defun hdstr (V4021) (pos V4021 0))

(defun intersection (V4028 V4029) (cond ((= () V4028) ()) ((cons? V4028) (if (element? (hd V4028) V4029) (cons (hd V4028) (intersection (tl V4028) V4029)) (intersection (tl V4028) V4029))) (true (simple-error "attempt to find the intersection with a non-list
"))))

(defun reverse (V4030) (shen.reverse-help V4030 ()))

(defun shen.reverse-help (V4035 V4036) (cond ((= () V4035) V4036) ((cons? V4035) (shen.reverse-help (tl V4035) (cons (hd V4035) V4036))) (true (simple-error "attempt to reverse a non-list
"))))

(defun union (V4041 V4042) (cond ((= () V4041) V4042) ((cons? V4041) (if (element? (hd V4041) V4042) (union (tl V4041) V4042) (cons (hd V4041) (union (tl V4041) V4042)))) (true (simple-error "attempt to find the union with a non-list
"))))

(defun y-or-n? (V4043) (let W4044 (pr (shen.proc-nl V4043) (stoutput)) (let W4045 (pr " (y/n) " (stoutput)) (let W4046 (shen.app (read (stinput)) "" shen.s) (if (= "y" W4046) true (if (= "n" W4046) false (do (pr "please answer y or n
" (stoutput)) (y-or-n? V4043))))))))

(defun not (V4047) (if V4047 false true))

(defun abort () (simple-error ""))

(defun subst (V4053 V4054 V4055) (cond ((= V4054 V4055) V4053) ((cons? V4055) (cons (subst V4053 V4054 (hd V4055)) (subst V4053 V4054 (tl V4055)))) (true V4055)))

(defun explode (V4056) (shen.explode-h (shen.app V4056 "" shen.a)))

(defun shen.explode-h (V4059) (cond ((= "" V4059) ()) ((shen.+string? V4059) (cons (hdstr V4059) (shen.explode-h (tlstr V4059)))) (true (simple-error "implementation error in explode-h"))))

(defun cd (V4060) (set *home-directory* (if (= V4060 "") "" (shen.app V4060 "/" shen.a))))

(defun shen.for-each (V4061 V4062) (cond ((= () V4062) true) ((cons? V4062) (let W4063 (V4061 (hd V4062)) (shen.for-each V4061 (tl V4062)))) (true (shen.f-error shen.for-each))))

(defun map (V4064 V4065) (shen.map-h V4064 V4065 ()))

(defun shen.map-h (V4066 V4067 V4068) (cond ((= () V4067) (reverse V4068)) ((cons? V4067) (shen.map-h V4066 (tl V4067) (cons (V4066 (hd V4067)) V4068))) (true (shen.f-error shen.map-h))))

(defun length (V4069) (shen.length-h V4069 0))

(defun shen.length-h (V4074 V4075) (cond ((= () V4074) V4075) (true (shen.length-h (tl V4074) (+ V4075 1)))))

(defun occurrences (V4081 V4082) (cond ((= V4081 V4082) 1) ((cons? V4082) (+ (occurrences V4081 (hd V4082)) (occurrences V4081 (tl V4082)))) (true 0)))

(defun nth (V4087 V4088) (cond ((and (= 1 V4087) (cons? V4088)) (hd V4088)) ((cons? V4088) (nth (- V4087 1) (tl V4088))) (true (simple-error (cn "nth applied to " (shen.app V4087 (cn ", " (shen.app V4088 "
" shen.a)) shen.a))))))

(defun integer? (V4089) (and (number? V4089) (let W4090 (shen.abs V4089) (shen.integer-test? W4090 (shen.magless W4090 1)))))

(defun shen.abs (V4091) (if (> V4091 0) V4091 (- 0 V4091)))

(defun shen.magless (V4092 V4093) (let W4094 (* V4093 2) (if (> W4094 V4092) V4093 (shen.magless V4092 W4094))))

(defun shen.integer-test? (V4098 V4099) (cond ((= 0 V4098) true) ((> 1 V4098) false) (true (let W4100 (- V4098 V4099) (if (> 0 W4100) (integer? V4098) (shen.integer-test? W4100 V4099))))))

(defun mapcan (V4107 V4108) (cond ((= () V4108) ()) ((cons? V4108) (append (V4107 (hd V4108)) (mapcan V4107 (tl V4108)))) (true (simple-error "attempt to mapcan over a non-list
"))))

(defun == (V4114 V4115) (cond ((= V4114 V4115) true) (true false)))

(defun bound? (V4116) (and (symbol? V4116) (let W4117 (trap-error (value V4116) (lambda Z4118 shen.this-symbol-is-unbound)) (if (= W4117 shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V4119) (cond ((= "" V4119) ()) (true (cons (string->n (pos V4119 0)) (shen.string->bytes (tlstr V4119))))))

(defun maxinferences (V4120) (set shen.*maxinferences* V4120))

(defun inferences () (value shen.*infs*))

(defun protect (V4121) V4121)

(defun sterror () (value *sterror*))

(defun stoutput () (value *stoutput*))

(defun string->symbol (V4122) (let W4123 (intern V4122) (if (symbol? W4123) W4123 (simple-error (cn "cannot intern " (shen.app V4122 " to a symbol" shen.s))))))

(defun optimise (V4126) (cond ((= + V4126) (set shen.*optimise* true)) ((= - V4126) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V4127) (cond ((= null V4127) true) (true (trap-error (do (external V4127) true) (lambda Z4128 false)))))

(defun fail () shen.fail!)(defun enable-type-theory (V4131) (cond ((= + V4131) (set shen.*shen-type-theory-enabled?* true)) ((= - V4131) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun tc (V4134) (cond ((= + V4134) (set shen.*tc* true)) ((= - V4134) (set shen.*tc* false)) (true (simple-error "tc expects a + or -"))))

(defun destroy (V4135) (do (set shen.*sigf* (shen.unassoc V4135 (value shen.*sigf*))) V4135))

(defun shen.unassoc (V4145 V4146) (cond ((= () V4146) ()) ((and (cons? V4146) (and (cons? (hd V4146)) (= V4145 (hd (hd V4146))))) (tl V4146)) ((cons? V4146) (cons (hd V4146) (shen.unassoc V4145 (tl V4146)))) (true (simple-error "implementation error in shen.unassoc"))))

(defun in-package (V4147) (if (package? V4147) (set shen.*package* V4147) (simple-error (cn "package " (shen.app V4147 " does not exist
" shen.a)))))

(defun write-to-file (V4148 V4149) (let W4150 (open V4148 out) (let W4151 (if (string? V4149) V4149 (shen.app V4149 "" shen.s)) (let W4152 (pr W4151 W4150) (let W4153 (close W4150) V4149)))))

(defun fresh () (shen.freshterm (gensym shen.t)))

(defun update-lambda-table (V4154 V4155) (let W4156 (put V4154 arity V4155 (value *property-vector*)) (let W4157 (shen.lambda-entry V4154) (let W4158 (shen.set-lambda-form-entry (cons V4154 W4157)) V4154))))

(defun specialise (V4161 V4162) (cond ((= 0 V4162) (do (set shen.*special* (remove V4161 (value shen.*special*))) (do (set shen.*extraspecial* (remove V4161 (value shen.*extraspecial*))) V4161))) ((= 1 V4162) (do (set shen.*special* (adjoin V4161 (value shen.*special*))) (do (set shen.*extraspecial* (remove V4161 (value shen.*extraspecial*))) V4161))) ((= 2 V4162) (do (set shen.*special* (remove V4161 (value shen.*special*))) (do (set shen.*extraspecial* (adjoin V4161 (value shen.*extraspecial*))) V4161))) (true (simple-error "specialise requires values of 0, 1 or 2
"))))

